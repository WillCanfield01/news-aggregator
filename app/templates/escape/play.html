{# app/templates/escape/play.html (REWRITE) #}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Escape — Play</title>
  <style>
    :root {
      --bg: #0e1222;
      --panel: #151a2f;
      --panel2: #0f1427;
      --text: #f5f6fa;
      --muted: #99a3c7;
      --accent: #58bbff;
      --ok: #68f2a1;
      --warn: #ffd166;
      --bad: #ff6b6b;
      --shadow: rgba(0, 0, 0, 0.45);
      --card: #121832;
      --line: #223057;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -20%, #1a1f3e 0%, #0e1222 55%, #0e1222 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .wrap {
      width: 100%;
      max-width: 820px;
      padding: 18px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .brand {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .meta {
      color: var(--muted);
      font-size: 14px;
    }

    .progress {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-top: 10px;
    }

    .step {
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      text-align: center;
      font-size: 14px;
      color: var(--muted);
    }

    .step.active {
      color: var(--text);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent) inset;
    }

    .panel {
      margin-top: 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
      padding: 12px;
    }

    .center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn {
      appearance: none;
      background: var(--accent);
      color: #08111e;
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(88, 187, 255, 0.35);
    }

    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .muted {
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .timer {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .ads {
      margin-top: 12px;
      height: 64px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .share {
      white-space: pre;
      background: #0b1225;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Vault Frenzy UI */
    .vf-grid {
      display: grid;
      gap: 10px;
      touch-action: manipulation;
    }

    .vf-cell {
      width: 86px;
      height: 86px;
      border-radius: 14px;
      background: #121832;
      border: 1px solid #223057;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      transition: transform .06s ease;
    }

    .vf-cell.flash {
      transform: scale(1.04);
      transition: transform .08s;
    }

    .vf-cell:active {
      transform: scale(0.96);
    }

    /* Light Reactor UI */
    .reactor {
      position: relative;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      background: #0e1a34;
      border: 2px solid #20335f;
      box-shadow: inset 0 0 60px rgba(32, 64, 128, .45);
    }

    .reactor .target {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 280px;
      height: 280px;
      margin: -140px 0 0 -140px;
      border-radius: 50%;
      border: 2px dashed #2954a8;
    }

    .reactor .orb {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #58bbff;
      box-shadow: 0 0 14px rgba(88, 187, 255, .9);
    }

    .reactor .zone {
      position: absolute;
      width: 260px;
      height: 260px;
      margin: -130px 0 0 -130px;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      border: 4px solid rgba(104, 242, 161, .45);
    }

    .reactor .cta {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Pressure Chamber UI */
    .pc-wrap {
      display: flex;
      gap: 12px;
    }

    .pc-valve {
      width: 70px;
      background: #0f1a33;
      border: 1px solid #223057;
      border-radius: 10px;
      padding: 6px;
    }

    .pc-gauge {
      height: 160px;
      background: linear-gradient(0deg, #1c2b5c, #14305a);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    .pc-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0%;
      background: linear-gradient(180deg, #68f2a1, #2a7f55);
      box-shadow: inset 0 0 18px rgba(0, 0, 0, .35);
      transition: height .12s linear;
    }

    .pc-btn {
      margin-top: 6px;
      width: 100%;
      font-weight: 700;
    }

    /* Finish */
    .finish {
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="brand">Daily Escape</div>
        <div class="meta"><span id="todayMeta"></span> • <span class="timer" id="globalTimer">0:00</span></div>
      </div>
      <div class="row">
        <button id="muteBtn" class="btn" style="background:#263a5f;color:#cfe2ff">🔇 Sound</button>
        <a href="/escape/leaderboard" class="btn" style="background:#1cf29f;">Leaderboard</a>
      </div>
    </header>

    <div class="progress">
      <div class="step active" id="stepA">◆ Vault Frenzy</div>
      <div class="step" id="stepB">◎ Light Reactor</div>
      <div class="step" id="stepC">✶ Pressure Chamber</div>
    </div>

    <div class="panel" id="panel">
      <div id="intro" class="center" style="flex-direction:column; padding:20px;">
        <h2 style="margin:4px 0 10px;">Ready to escape?</h2>
        <p class="muted" style="text-align:center; max-width:520px;">
          Three quick minigames. One escape. Finish as fast as you can.
        </p>
        <div class="ads">Ad slot</div>
        <div style="height:8px;"></div>
        <button id="startBtn" class="btn">Start</button>
      </div>

      <div id="gameA" style="display:none;"></div>
      <div id="gameB" style="display:none;"></div>
      <div id="gameC" style="display:none;"></div>

      <div id="finish" class="finish" style="display:none;">
        <h2>Escaped!</h2>
        <p>Total time: <b><span id="totalMs"></span> ms</b></p>
        <div class="row center" style="justify-content:center;">
          <div id="shareBlock" class="share"></div>
        </div>
        <div style="height:10px;"></div>
        <a href="/escape/leaderboard" class="btn">See Leaderboard</a>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // ---------- utils ----------
      const $ = (s) => document.querySelector(s);
      const todayISO = () => new Date().toISOString().slice(0, 10);
      const qs = new URLSearchParams(location.search);

      // Mulberry32: simple seeded PRNG
      function m32(seed) { return function () { seed |= 0; seed = (seed + 0x6D2B79F5) | 0; let t = Math.imul(seed ^ (seed >>> 15), 1 | seed); t ^= t + Math.imul(t ^ (t >>> 7), 61 | t); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }; }
      function choice(rng, arr) { return arr[Math.floor(rng() * arr.length)] }

      const state = {
        dateKey: qs.get("date") || todayISO(),
        minis: [],
        current: 0,
        startedMs: null,
        soundOn: (localStorage.getItem("escape_sound") || "on") === "on",
        answers: {} // puzzleId -> string
      };

      document.addEventListener("DOMContentLoaded", init);

      async function init() {
        await fetchMinis();
        // header
        $("#todayMeta").textContent = `${state.dateKey} • ${state.theme || 'Daily Escape'}`;
        $("#startBtn").onclick = startRun;
        $("#muteBtn").onclick = () => {
          state.soundOn = !state.soundOn;
          localStorage.setItem("escape_sound", state.soundOn ? "on" : "off");
          $("#muteBtn").textContent = state.soundOn ? "🔊 Sound" : "🔇 Sound";
        };
      }

      async function fetchMinis() {
        const res = await fetch(`/escape/api/today?format=minis&date=${encodeURIComponent(state.dateKey)}`);
        if (!res.ok) throw new Error("today fetch failed");
        const data = await res.json();
        state.theme = data.theme;
        state.minis = (data.minigames || []).map(m => ({
          slot: m.slot || m.id,
          id: m.puzzle_id || m.id,
          mechanic: (m.mechanic || (m.ui || {}).kind || "").toLowerCase(),
          prompt: m.prompt || "",
          ui: m.ui_spec || m.ui || {}
        }));
      }

      // ---------- flow ----------
      function startRun() {
        state.startedMs = Date.now();
        $("#intro").style.display = "none";
        showCurrent();
      }

      function showCurrent() {
        const containers = ["#gameA", "#gameB", "#gameC"].map($);
        containers.forEach((el, i) => el.style.display = (i === state.current) ? "block" : "none");
        const mini = state.minis[state.current];
        const host = containers[state.current]; host.innerHTML = "";

        // shared header
        const h = document.createElement("div");
        h.innerHTML = `<h3 style="margin:6px 0 8px;">${["A", "B", "C"][state.current]} • ${titleFor(mini)}</h3><p class="muted" style="max-width:780px">${mini.prompt}</p>`;
        host.appendChild(h);

        if (mini.mechanic === "vault_frenzy") mountVaultFrenzy(host, mini);
        else if (mini.mechanic === "phantom_doors") mountPhantomDoors(host, mini);
        else if (mini.mechanic === "pressure_chamber") mountPressureChamber(host, mini);
        else host.innerHTML += `<p>Unsupported mini: ${mini.mechanic}</p>`;
      }

      function titleFor(mini) {
        return mini.mechanic === "vault_frenzy" ? "Vault Frenzy" :
          mini.mechanic === "phantom_doors" ? "Phantom Doors" :
            mini.mechanic === "pressure_chamber" ? "Pressure Chamber" : "Puzzle";
      }

      async function submitAnswer(mini, answerStr) {
        state.answers[mini.id] = answerStr;
        const body = { date_key: state.dateKey, puzzle_id: mini.id, answer: answerStr };
        const res = await fetch("/escape/api/submit", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        const data = await res.json();
        if (data && data.correct) {
          advance();
        } else {
          // soft fail
          flash(hostOf(mini), "#ff6b6b");
        }
      }

      function advance() {
        if (state.current < 2) { state.current += 1; showCurrent(); return; }
        finishRun(true);
      }

      async function finishRun(success) {
        const body = {
          date_key: state.dateKey,
          started_ms: state.startedMs,
          success,
          meta: {}
        };
        await fetch("/escape/api/finish", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        // show finish UI
        ["#gameA", "#gameB", "#gameC"].forEach(sel => $(sel).style.display = "none");
        $("#finish").style.display = "block";
        $("#totalMs").textContent = (Date.now() - state.startedMs);
        $("#shareBlock").textContent = `Daily Escape ${state.dateKey}\n${Object.keys(state.answers).length}/3 cleared`;
      }

      function hostOf(mini) {
        return [$("#gameA"), $("#gameB"), $("#gameC")][state.current];
      }

      function flash(el, color = "#68f2a1") { el.style.boxShadow = `0 0 0 2px ${color}`; setTimeout(() => el.style.boxShadow = "", 220); }

      // ---------- Minis ----------
      function mountVaultFrenzy(host, mini) {
        const ui = mini.ui || {};
        const g = ui.grid || { rows: 3, cols: 4 };
        const tempo = ui.tempo_ms || 520;
        const rules = ui.rules || {};
        const rng = m32(ui.seed || 1);

        // Server declares exact counts (we fall back sensibly)
        const length = ui.length || 8;
        const trueCount = ui.true_count ?? 6;
        const decoyCount = ui.decoy_count ?? Math.max(0, length - trueCount);

        // --- help
        const help = document.createElement("div");
        help.className = "muted";
        help.style.margin = "6px 0 12px";
        help.innerHTML =
          "Watch the pattern once, then tap back the <b>true</b> flashes in order. " +
          "True flashes highlight <b>green</b>; decoys are red and are ignored. " +
          "Press <b>Play</b> to see it again (resets your input).";
        host.appendChild(help);

        // --- grid
        const grid = document.createElement("div");
        grid.className = "vf-grid";
        grid.style.gridTemplateColumns = `repeat(${g.cols}, 86px)`;
        const cells = [];
        for (let r = 0; r < g.rows; r++) {
          for (let c = 0; c < g.cols; c++) {
            const cell = document.createElement("div");
            cell.className = "vf-cell";
            cell.dataset.rc = `${r}-${c}`;
            grid.appendChild(cell);
            cells.push(cell);
          }
        }
        host.appendChild(grid);

        // --- controls
        const ctrls = document.createElement("div");
        ctrls.style.display = "flex"; ctrls.style.gap = "8px"; ctrls.style.marginTop = "10px";
        const playBtn = btn("▶ Play", () => startPlayback(true));
        const clearBtn = btn("Clear", resetInput);
        const backBtn = btn("⌫", () => { if (!inputEnabled) return; picks.pop(); updateProgress(); redrawSelections(); });
        const goBtn = btn("Go", () => submitAnswer(mini, picks.join(",")));
        goBtn.disabled = true;
        ctrls.append(playBtn, clearBtn, backBtn, goBtn);
        host.appendChild(ctrls);

        const prog = document.createElement("div");
        prog.className = "muted"; prog.style.marginTop = "4px";
        host.appendChild(prog);

        function btn(t, fn) { const b = document.createElement("button"); b.className = "btn"; b.textContent = t; b.onclick = fn; return b; }

        // === Build the exact same event stream the server used ===
        // Shuffle mask of T/D with seeded RNG (order matters)
        const mask = Array(trueCount).fill("T").concat(Array(decoyCount).fill("D"));
        for (let i = mask.length - 1; i > 0; i--) {
          const j = Math.floor(rng() * (i + 1));[mask[i], mask[j]] = [mask[j], mask[i]];
        }
        const events = mask.map(tag => {
          const r = Math.floor(rng() * g.rows), c = Math.floor(rng() * g.cols);
          return {
            r, c,
            isDecoy: tag === "D",
            dbl: rng() < (rules.double_blink_prob ?? 0.12),
            delay: rng() < (rules.delayed_glow_prob ?? 0.12),
          };
        });
        const trueSeq = events.filter(e => !e.isDecoy).map(e => `${e.r}-${e.c}`); // expected order

        // Input state (post-playback)
        let inputEnabled = false;
        let picks = [];
        updateProgress();

        // Cell visuals
        function setFlash(cell, color, on) {
          if (on) {
            cell.style.outline = `2px solid ${color}`;
            cell.style.background = (color === "#6bf2a9") ? "#1e2a54" : "#2a1e27";
          } else {
            cell.style.outline = "";
            cell.style.background = "";
          }
        }
        function flashCell(cell, color, onMs) {
          setFlash(cell, color, true);
          setTimeout(() => setFlash(cell, color, false), onMs);
        }
        function redrawSelections() {
          // Clear all selection rings, then add subtle ring for chosen cells
          cells.forEach(c => c.style.boxShadow = "");
          picks.forEach((rc, i) => {
            const [r, c] = rc.split("-").map(Number);
            const el = cells[r * g.cols + c];
            el.style.boxShadow = "0 0 0 2px rgba(107,242,169,.65) inset";
          });
        }

        // Input handler (after playback)
        grid.onclick = (ev) => {
          if (!inputEnabled) return;
          const cell = ev.target.closest(".vf-cell");
          if (!cell) return;
          const rc = cell.dataset.rc;

          const need = trueSeq[picks.length];
          if (rc === need) {
            picks.push(rc);
            updateProgress();
            redrawSelections();
            // Auto-submit when complete (or leave for Go)
            if (picks.length === trueSeq.length) {
              goBtn.disabled = false;
              // submitAnswer(mini, picks.join(",")); // uncomment to auto-submit
            }
          } else {
            // tiny error feedback
            cell.classList.add("flash");
            setTimeout(() => cell.classList.remove("flash"), 120);
          }
        };

        function updateProgress() {
          prog.textContent = `taps ${picks.length}/${trueSeq.length}`;
          goBtn.disabled = (picks.length !== trueSeq.length);
        }
        function resetInput() {
          if (!inputEnabled) return;
          picks = [];
          updateProgress();
          redrawSelections();
        }

        // Playback: show full pattern; decoys flash red, trues green
        function startPlayback(reset) {
          inputEnabled = false;
          if (reset) { picks = []; updateProgress(); redrawSelections(); }

          cells.forEach(c => setFlash(c, "#000", false));
          let t = 0;
          const onMs = Math.floor(tempo * 0.6);

          events.forEach(ev => {
            const cell = cells[ev.r * g.cols + ev.c];
            const show = () => flashCell(cell, ev.isDecoy ? "#ff6b6b" : "#6bf2a9", onMs);
            const lead = ev.delay ? Math.floor(tempo * 0.25) : 0;
            setTimeout(() => {
              show();
              if (ev.dbl) setTimeout(show, Math.floor(onMs * 0.8));
            }, t + lead);
            t += tempo;
          });

          // enable input after the final flash
          setTimeout(() => { inputEnabled = true; }, t + 30);
        }

        // auto-play once so the player sees the pattern
        setTimeout(() => startPlayback(false), 200);
      }

      function mountPhantomDoors(host, mini) {
        const ui = mini.ui || {};
        const glyphs = (ui.glyphs || ["◇", "◆", "○", "●", "△", "▲", "□", "■"]).slice(0, 8);

        // Seeded, deterministic sequence for today
        const rng = m32(ui.seed || 1);
        const seq = [];
        for (let i = 0; i < (ui.rounds || 6); i++) {
          seq.push(glyphs[Math.floor(rng() * glyphs.length)]);
        }

        // Top bar: ▶ Show sequence (replay any time)
        const top = document.createElement("div");
        top.style.display = "flex"; top.style.alignItems = "center"; top.style.gap = "10px";
        const seqBar = document.createElement("div"); seqBar.className = "muted"; seqBar.textContent = "Sequence shown";
        const showBtn = document.createElement("button"); showBtn.className = "btn"; showBtn.textContent = "▶ Show";
        showBtn.onclick = () => {
          seqBar.textContent = ""; let i = 0;
          const timer = setInterval(() => {
            seqBar.textContent = seq.slice(0, ++i).join(" ");
            if (i >= seq.length) clearInterval(timer);
          }, ui.flash_ms || 480);
        };
        top.append(showBtn, seqBar);
        host.appendChild(top);

        // Door grid (this was missing)
        const layout = document.createElement("div");
        layout.style.display = "grid";
        layout.style.gridTemplateColumns = "repeat(4, 1fr)";
        layout.style.gap = "10px";
        host.appendChild(layout);

        // Create 8 door buttons
        const doors = new Array(8).fill(0).map(() => {
          const d = document.createElement("button");
          d.className = "btn";
          d.style.background = "#22345d";
          d.style.color = "#cfe0ff";
          d.style.padding = "18px 0";
          d.textContent = "◇";
          layout.appendChild(d);
          return d;
        });

        const picks = [];

        function reshuffle() {
          // assign random glyphs; some doors are phantoms
          const phCount = Math.max(1, Math.floor(doors.length * (ui.phantom_rate || 0.25)));
          const phantomSet = new Set();
          while (phantomSet.size < phCount) phantomSet.add(Math.floor(rng() * doors.length));

          doors.forEach((d, i) => {
            d.disabled = false;
            d.textContent = glyphs[Math.floor(rng() * glyphs.length)];
            d.dataset.glyph = d.textContent;
            d.style.opacity = 1;

            if (phantomSet.has(i)) d.dataset.phantom = "1"; else delete d.dataset.phantom;

            d.onclick = () => {
              if (d.dataset.phantom === "1") { d.style.opacity = 0.33; return; }
              picks.push(d.dataset.glyph);
              if (picks.length === seq.length) {
                submitAnswer(mini, picks.join(","));
              } else {
                reshuffle();
              }
            };
          });
        }

        reshuffle();
      }

      // PRESSURE CHAMBER: animate gauges; accept a pre-computed order of labels
      function mountPressureChamber(host, mini) {
        const ui = mini.ui || {};
        const targetCount = ui.target_count || 8;
        let picks = [];

        // HUD (taps left + ⟲ Restart)
        const hud = document.createElement("div");
        hud.className = "muted"; hud.style.margin = "6px 0 12px";
        const left = document.createElement("span");
        const rst = document.createElement("button"); rst.className = "btn"; rst.textContent = "⟲ Restart";
        hud.append(left, document.createTextNode(" "), rst);
        host.appendChild(hud);

        // Container for valves (this was missing in your file)
        const wrap = document.createElement("div");
        wrap.className = "pc-wrap";
        host.appendChild(wrap);

        const valves = (ui.valves || []).map(v => ({ ...v, level: 0 }));
        const rng = m32(ui.seed || 1);

        const buttons = [];
        valves.forEach((v) => {
          const col = document.createElement("div"); col.className = "pc-valve";
          const g = document.createElement("div"); g.className = "pc-gauge";
          const fill = document.createElement("div"); fill.className = "pc-fill";
          g.appendChild(fill);
          const b = document.createElement("button"); b.className = "btn pc-btn"; b.textContent = v.label;
          b.onclick = () => {
            picks.push(v.label);
            v.level = Math.max(0, v.level - 0.6); // drop pressure
            updateLeft();
            if (picks.length >= targetCount) submitAnswer(mini, picks.join(","));
          };
          col.appendChild(g); col.appendChild(b);
          wrap.appendChild(col);
          buttons.push({ fill, btn: b, valve: v });
        });

        function updateLeft() { left.textContent = `taps left: ${Math.max(0, targetCount - picks.length)}`; }
        updateLeft();

        rst.onclick = () => {
          picks = [];
          valves.forEach(v => v.level = 0);
          buttons.forEach(({ fill }) => (fill.style.height = "0%"));
          updateLeft();
        };

        const tickMs = ui.tempo_ms || 90;
        function frame() {
          buttons.forEach(({ fill, valve }) => {
            const drift = (valve.base || 0.2) + (rng() - 0.5) * (valve.var || 0.1);
            valve.level = Math.min(1.2, valve.level + Math.max(0.02, drift) * (tickMs / 1000));
            fill.style.height = Math.max(0, Math.min(100, valve.level * 100)) + "%";
            if (valve.level >= 1.0) {
              valve.level = 1.0;
              fill.style.background = "linear-gradient(180deg,#ff6b6b,#9b2e2e)"; // overflow warning
            }
          });
          setTimeout(frame, tickMs);
        }
        frame();
      }

    })();
  </script>

</body>

</html>