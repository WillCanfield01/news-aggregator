{# app/templates/escape/play.html (REWRITE) #}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Escape â€” Play</title>
  <style>
    :root {
      --bg: #0e1222;
      --panel: #151a2f;
      --panel2: #0f1427;
      --text: #f5f6fa;
      --muted: #99a3c7;
      --accent: #58bbff;
      --ok: #68f2a1;
      --warn: #ffd166;
      --bad: #ff6b6b;
      --shadow: rgba(0, 0, 0, 0.45);
      --card: #121832;
      --line: #223057;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -20%, #1a1f3e 0%, #0e1222 55%, #0e1222 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .wrap {
      width: 100%;
      max-width: 820px;
      padding: 18px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .brand {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .meta {
      color: var(--muted);
      font-size: 14px;
    }

    .progress {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-top: 10px;
    }

    .step {
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      text-align: center;
      font-size: 14px;
      color: var(--muted);
    }

    .step.active {
      color: var(--text);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent) inset;
    }

    .panel {
      margin-top: 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
      padding: 12px;
    }

    .center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn {
      appearance: none;
      background: var(--accent);
      color: #08111e;
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(88, 187, 255, 0.35);
    }

    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .muted {
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .timer {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .ads {
      margin-top: 12px;
      height: 64px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .share {
      white-space: pre;
      background: #0b1225;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Vault Frenzy UI */
    .vf-grid {
      display: grid;
      gap: 10px;
      touch-action: manipulation;
    }

    .vf-cell {
      width: 86px;
      height: 86px;
      border-radius: 14px;
      background: #121832;
      border: 1px solid #223057;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      transition: transform .06s ease;
    }

    .vf-cell.flash {
      transform: scale(1.04);
      transition: transform .08s;
    }

    .vf-cell:active {
      transform: scale(0.96);
    }

    /* Light Reactor UI */
    .reactor {
      position: relative;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      background: #0e1a34;
      border: 2px solid #20335f;
      box-shadow: inset 0 0 60px rgba(32, 64, 128, .45);
    }

    .reactor .target {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 280px;
      height: 280px;
      margin: -140px 0 0 -140px;
      border-radius: 50%;
      border: 2px dashed #2954a8;
    }

    .reactor .orb {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #58bbff;
      box-shadow: 0 0 14px rgba(88, 187, 255, .9);
    }

    .reactor .zone {
      position: absolute;
      width: 260px;
      height: 260px;
      margin: -130px 0 0 -130px;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      border: 4px solid rgba(104, 242, 161, .45);
    }

    .reactor .cta {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Pressure Chamber UI */
    .pc-wrap {
      display: flex;
      gap: 12px;
    }

    .pc-valve {
      width: 70px;
      background: #0f1a33;
      border: 1px solid #223057;
      border-radius: 10px;
      padding: 6px;
    }

    .pc-gauge {
      height: 160px;
      background: linear-gradient(0deg, #1c2b5c, #14305a);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    .pc-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0%;
      background: linear-gradient(180deg, #68f2a1, #2a7f55);
      box-shadow: inset 0 0 18px rgba(0, 0, 0, .35);
      transition: height .12s linear;
    }

    .pc-btn {
      margin-top: 6px;
      width: 100%;
      font-weight: 700;
    }

    /* Finish */
    .finish {
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="brand">Daily Escape</div>
        <div class="meta"><span id="todayMeta"></span> â€¢ <span class="timer" id="globalTimer">0:00</span></div>
      </div>
      <div class="row">
        <button id="muteBtn" class="btn" style="background:#263a5f;color:#cfe2ff">ðŸ”‡ Sound</button>
        <a href="/escape/leaderboard" class="btn" style="background:#1cf29f;">Leaderboard</a>
      </div>
    </header>

    <div class="progress">
      <div class="step active" id="stepA">â—† Vault Frenzy</div>
      <div class="step" id="stepB">â—Ž Phantom Doors</div>
      <div class="step" id="stepC">âœ¶ Pressure Chamber</div>
    </div>

    <div class="panel" id="panel">
      <div id="intro" class="center" style="flex-direction:column; padding:20px;">
        <h2 style="margin:4px 0 10px;">Ready to escape?</h2>
        <p class="muted" style="text-align:center; max-width:520px;">
          Three quick minigames. One escape. Finish as fast as you can.
        </p>
        <div class="ads">Ad slot</div>
        <div style="height:8px;"></div>
        <button id="startBtn" class="btn">Start</button>
      </div>

      <div id="gameA" style="display:none;"></div>
      <div id="gameB" style="display:none;"></div>
      <div id="gameC" style="display:none;"></div>

      <div id="finish" class="finish" style="display:none;">
        <h2>Escaped!</h2>
        <p>Total time: <b><span id="totalMs"></span> ms</b></p>
        <div class="row center" style="justify-content:center;">
          <div id="shareBlock" class="share"></div>
        </div>
        <div style="height:10px;"></div>
        <a href="/escape/leaderboard" class="btn">See Leaderboard</a>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // ---------- utils ----------
      const $ = (s) => document.querySelector(s);
      const todayISO = () => new Date().toISOString().slice(0, 10);
      const qs = new URLSearchParams(location.search);

      // Mulberry32: simple seeded PRNG
      function m32(seed) { return function () { seed |= 0; seed = (seed + 0x6D2B79F5) | 0; let t = Math.imul(seed ^ (seed >>> 15), 1 | seed); t ^= t + Math.imul(t ^ (t >>> 7), 61 | t); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }; }
      function choice(rng, arr) { return arr[Math.floor(rng() * arr.length)] }

      const state = {
        dateKey: qs.get("date") || todayISO(),
        minis: [],
        current: 0,
        startedMs: null,
        soundOn: (localStorage.getItem("escape_sound") || "on") === "on",
        answers: {} // puzzleId -> string
      };

      document.addEventListener("DOMContentLoaded", init);

      async function init() {
        await fetchMinis();
        // header
        $("#todayMeta").textContent = `${state.dateKey} â€¢ ${state.theme || 'Daily Escape'}`;
        $("#startBtn").onclick = startRun;
        $("#muteBtn").onclick = () => {
          state.soundOn = !state.soundOn;
          localStorage.setItem("escape_sound", state.soundOn ? "on" : "off");
          $("#muteBtn").textContent = state.soundOn ? "ðŸ”Š Sound" : "ðŸ”‡ Sound";
        };
      }

      async function fetchMinis() {
        const res = await fetch(`/escape/api/today?format=minis&date=${encodeURIComponent(state.dateKey)}`);
        if (!res.ok) throw new Error("today fetch failed");
        const data = await res.json();
        state.theme = data.theme;
        state.minis = (data.minigames || []).map(m => ({
          slot: m.slot || m.id,
          // keep both for clarity
          puzzle_id: m.puzzle_id || m.id,
          id: m.puzzle_id || m.id,
          mechanic: (m.mechanic || (m.ui || {}).kind || "").toLowerCase(),
          prompt: m.prompt || "",
          ui: m.ui_spec || m.ui || {},
          // <â€” retain solution so Phantom Doors can see what the server expects
          solution: m.solution || null
        }));
      }

      // ---------- flow ----------
      function startRun() {
        state.startedMs = Date.now();
        $("#intro").style.display = "none";
        showCurrent();
      }

      function showCurrent() {
        const containers = ["#gameA", "#gameB", "#gameC"].map($);
        containers.forEach((el, i) => el.style.display = (i === state.current) ? "block" : "none");

        // Update the header tabs' active state
        ["#stepA", "#stepB", "#stepC"].forEach((sel, i) => {
          const el = $(sel);
          if (el) el.classList.toggle("active", i === state.current);
        });

        const mini = state.minis[state.current];
        const host = containers[state.current];
        host.innerHTML = "";

        // shared header
        const titles = ["A", "B", "C"];
        const h = document.createElement("div");
        h.innerHTML = `<h3 style="margin:6px 0 8px;">${titles[state.current]} â€¢ ${titleFor(mini)}</h3>
                       <p class="muted" style="max-width:780px">${mini.prompt}</p>`;
        host.appendChild(h);

        if (mini.mechanic === "vault_frenzy") mountVaultFrenzy(host, mini);
        else if (mini.mechanic === "phantom_doors") mountPhantomDoors(host, mini);
        else if (mini.mechanic === "pressure_chamber") mountPressureChamber(host, mini);
        else host.innerHTML += `<p>Unsupported mini: ${mini.mechanic}</p>`;
      }

      function titleFor(mini) {
        return mini.mechanic === "vault_frenzy" ? "Vault Frenzy" :
          mini.mechanic === "phantom_doors" ? "Phantom Doors" :
            mini.mechanic === "pressure_chamber" ? "Pressure Chamber" : "Puzzle";
      }

      async function submitAnswer(mini, answerStr) {
        // send the REAL saved id the server verifies against
        const body = {
          date_key: state.dateKey,           // keep for server
          date: state.dateKey,               // also send 'date' for tolerance
          puzzle_id: mini.puzzle_id || mini.id,
          answer: answerStr
        };
        const res = await fetch("/escape/api/submit", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        if (data && data.correct) {
          advance();
        } else {
          // soft fail
          flash(hostOf(mini), "#ff6b6b");
        }
      }

      function advance() {
        if (state.current < 2) { state.current += 1; showCurrent(); return; }
        finishRun(true);
      }

      async function finishRun(success) {
        const body = {
          date_key: state.dateKey,
          started_ms: state.startedMs,
          success,
          meta: {}
        };
        await fetch("/escape/api/finish", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        // show finish UI
        ["#gameA", "#gameB", "#gameC"].forEach(sel => $(sel).style.display = "none");
        $("#finish").style.display = "block";
        $("#totalMs").textContent = (Date.now() - state.startedMs);
        $("#shareBlock").textContent = `Daily Escape ${state.dateKey}\n${Object.keys(state.answers).length}/3 cleared`;
      }

      function hostOf(mini) {
        return [$("#gameA"), $("#gameB"), $("#gameC")][state.current];
      }

      function flash(el, color = "#68f2a1") { el.style.boxShadow = `0 0 0 2px ${color}`; setTimeout(() => el.style.boxShadow = "", 220); }

      // ---------- Minis ----------
      function mountVaultFrenzy(host, mini) {
        const ui = mini.ui || {};
        // normalize grid from ui_spec (server sends grid_rows/grid_cols)
        const g = {
          rows: (ui.grid && ui.grid.rows) || ui.grid_rows || 4,
          cols: (ui.grid && ui.grid.cols) || ui.grid_cols || 4
        };
        const tempo = ui.tempo_ms || 520;

        // ---- USE SERVER DATA (deterministic + refreshes after regen)
        // true_indices define the exact ordered solution; decoys can be shown anywhere.
        const trueIdx = (ui.true_indices || []).slice();
        const decoyIdx = (ui.decoy_indices || []).slice();

        const idxToRC = (i) => `${Math.floor(i / g.cols)}-${i % g.cols}`;
        const trueSeq = trueIdx.map(idxToRC); // expected tap order (matches server)

        // --- help
        const help = document.createElement("div");
        help.className = "muted";
        help.style.margin = "6px 0 12px";
        help.innerHTML =
          "Watch the pattern once, then tap back the <b>true</b> flashes in order. " +
          "True flashes highlight <b>green</b>; decoys are red and are ignored. " +
          "Press <b>Play</b> to see it again (resets your input).";
        host.appendChild(help);

        // --- grid
        const grid = document.createElement("div");
        grid.className = "vf-grid";
        grid.style.gridTemplateColumns = `repeat(${g.cols}, 86px)`;
        const cells = [];
        for (let r = 0; r < g.rows; r++) {
          for (let c = 0; c < g.cols; c++) {
            const cell = document.createElement("div");
            cell.className = "vf-cell";
            cell.dataset.rc = `${r}-${c}`;
            grid.appendChild(cell);
            cells.push(cell);
          }
        }
        host.appendChild(grid);

        // --- controls
        const ctrls = document.createElement("div");
        ctrls.style.display = "flex"; ctrls.style.gap = "8px"; ctrls.style.marginTop = "10px";
        const playBtn = btn("â–¶ Play", () => startPlayback(true));
        const clearBtn = btn("Clear", resetInput);
        const backBtn = btn("âŒ«", () => { if (!inputEnabled) return; picks.pop(); updateProgress(); redrawSelections(); });
        // Submit indices so it matches any server canonicalization path
        const goBtn = btn("Go", () => {
          const answer = picks.map(rc => {
            const [r, c] = rc.split("-").map(Number);
            return (r * g.cols + c);
          }).join(",");
          submitAnswer(mini, answer);
        });
        goBtn.disabled = true;
        ctrls.append(playBtn, clearBtn, backBtn, goBtn);
        host.appendChild(ctrls);

        const prog = document.createElement("div");
        prog.className = "muted"; prog.style.marginTop = "4px";
        host.appendChild(prog);

        function btn(t, fn) { const b = document.createElement("button"); b.className = "btn"; b.textContent = t; b.onclick = fn; return b; }

        // === Build the playback event timeline from server indices ===
        // We interleave decoys at a couple of fixed slots; solution order is still trueSeq.
        const events = [];
        const decoySlots = decoyIdx.length === 2 ? [1, 4] : (decoyIdx.length === 1 ? [2] : []);
        let d = 0;
        for (let i = 0; i < trueIdx.length; i++) {
          if (decoySlots.includes(i) && d < decoyIdx.length) {
            const di = decoyIdx[d++]; events.push({ r: Math.floor(di / g.cols), c: (di % g.cols), isDecoy: true, dbl: true, delay: false });
          }
          const ti = trueIdx[i]; events.push({ r: Math.floor(ti / g.cols), c: (ti % g.cols), isDecoy: false, dbl: false, delay: false });
        }
        while (d < decoyIdx.length) {
          const di = decoyIdx[d++]; events.push({ r: Math.floor(di / g.cols), c: (di % g.cols), isDecoy: true, dbl: true, delay: false });
        }

        // Input state (post-playback)
        let inputEnabled = false;
        let picks = [];
        updateProgress();

        // Cell visuals
        function setFlash(cell, color, on) {
          if (on) {
            cell.style.outline = `2px solid ${color}`;
            cell.style.background = (color === "#6bf2a9") ? "#1e2a54" : "#2a1e27";
          } else {
            cell.style.outline = "";
            cell.style.background = "";
          }
        }
        function flashCell(cell, color, onMs) {
          setFlash(cell, color, true);
          setTimeout(() => setFlash(cell, color, false), onMs);
        }
        function redrawSelections() {
          cells.forEach(c => c.style.boxShadow = "");
          picks.forEach((rc) => {
            const [r, c] = rc.split("-").map(Number);
            const el = cells[r * g.cols + c];
            el.style.boxShadow = "0 0 0 2px rgba(107,242,169,.65) inset";
          });
        }

        // Allow any taps; server verifies the ordered sequence.
        grid.onclick = (ev) => {
          if (!inputEnabled) return;
          const cell = ev.target.closest(".vf-cell");
          if (!cell) return;
          const rc = cell.dataset.rc;

          if (picks.length >= trueSeq.length) return;  // don't overrun
          picks.push(rc);
          updateProgress();
          redrawSelections();

          // subtle feedback if not the expected next cell
          const need = trueSeq[picks.length - 1];
          if (rc !== need) {
            cell.classList.add("flash");
            setTimeout(() => cell.classList.remove("flash"), 120);
          }

          if (picks.length === trueSeq.length) goBtn.disabled = false;
        };

        function updateProgress() {
          prog.textContent = `taps ${picks.length}/${trueSeq.length}`;
          goBtn.disabled = (picks.length !== trueSeq.length);
        }
        function resetInput() {
          if (!inputEnabled) return;
          picks = [];
          updateProgress();
          redrawSelections();
        }

        // Playback: show full pattern; decoys flash red, trues green
        function startPlayback(reset) {
          let __clockStarted = false;
          function startClock() {
            if (__clockStarted) return;
            __clockStarted = true;
            const label = document.getElementById("globalTimer"); // â† was #escape-elapsed
            if (!label) return;
            const t0 = Date.now();
            const fmt = s => `${Math.floor(s / 60)}:${String(s % 60).padStart(2, "0")}`;
            setInterval(() => {
              const s = Math.floor((Date.now() - t0) / 1000);
              label.textContent = fmt(s);
            }, 1000);
          }
          inputEnabled = false;
          if (reset) { picks = []; updateProgress(); redrawSelections(); }

          // Start the clock on first playback
          startClock();

          cells.forEach(c => setFlash(c, "#000", false));
          let t = 0;
          const onMs = Math.floor(tempo * 0.6);

          events.forEach(ev => {
            const cell = cells[ev.r * g.cols + ev.c];
            const show = () => flashCell(cell, ev.isDecoy ? "#ff6b6b" : "#6bf2a9", onMs);
            setTimeout(() => {
              show();
              if (ev.dbl) setTimeout(show, Math.floor(onMs * 0.8));
            }, t);
            t += tempo;
          });

          // enable input after the final flash
          setTimeout(() => { inputEnabled = true; }, t + 30);
        }

        // auto-play once so the player sees the pattern
        setTimeout(() => startPlayback(false), 200);
      }

      function mountPhantomDoors(host, mini) {
        // ---- Server payload ----
        const ui = mini.ui || {};
        const symbols = (ui.symbols || ["â–²", "â—", "â—†", "â– ", "âœ¶", "âœ¦"]).slice();
        const rounds = Math.max(1, Number(ui.rounds || 3));
        const shuffles = (ui.shuffles || []).map(a => a.slice());
        const phantoms = (ui.phantoms || Array(rounds).fill(-1)).slice();
        const tempo = Number(ui.tempo_ms || 600);

        // Raw answer string -> numbers
        const stored = (mini.solution && mini.solution.answer)
          ? String(mini.solution.answer).split(",").map(x => parseInt(x, 10))
          : [];

        // Helpers for round r
        const posToSym = (r) => (Array.isArray(shuffles[r]) && shuffles[r].length)
          ? shuffles[r] : symbols.map((_, i) => i);
        const symToPos = (r) => {
          const p2s = posToSym(r);
          const inv = new Array(p2s.length);
          for (let pos = 0; pos < p2s.length; pos++) inv[p2s[pos]] = pos;
          return inv;
        };

        // Build the SYMBOL sequence we will show and check, round-by-round.
        // If ui.sequence exists, trust it. Else detect for EACH round whether stored[r]
        // is a position (0..5) or a symbol index by round-tripping.
        const seqSymIdx = new Array(rounds).fill(0).map((_, r) => {
          if (Array.isArray(ui.sequence) && ui.sequence[r] != null) return Number(ui.sequence[r]);
          const sv = stored[r];
          if (sv == null || Number.isNaN(sv)) return 0;
          const p2s = posToSym(r), s2p = symToPos(r);
          const asPosSym = p2s[sv];             // interpret stored as POSITION -> symbol idx
          const roundTrip = s2p[asPosSym];      // POSITION -> symbol -> POSITION
          return (roundTrip === sv) ? asPosSym : Number(sv); // choose the consistent interpretation
        });

        // ---- Layout ----
        const help = document.createElement("div");
        help.className = "muted";
        help.style.margin = "6px 0 12px";
        help.innerHTML = "Memorize the symbol sequence. Doors reshuffle each round. Avoid phantom doors (they fade)!";
        host.appendChild(help);

        const seqBar = document.createElement("div");
        seqBar.style.display = "flex"; seqBar.style.gap = "10px"; seqBar.style.alignItems = "center"; seqBar.style.margin = "8px 0 14px";
        const showBtn = document.createElement("button"); showBtn.className = "btn"; showBtn.textContent = "â–¶ Show";
        const seqWrap = document.createElement("div"); seqWrap.style.display = "flex"; seqWrap.style.gap = "8px"; seqWrap.style.fontSize = "20px"; seqWrap.style.opacity = "0.9";
        seqBar.appendChild(showBtn); seqBar.appendChild(seqWrap); host.appendChild(seqBar);

        const corridor = document.createElement("div");
        corridor.style.display = "grid"; corridor.style.gridTemplateColumns = "repeat(3, 220px)"; corridor.style.gridAutoRows = "86px"; corridor.style.gap = "18px";
        host.appendChild(corridor);

        const ctrls = document.createElement("div");
        ctrls.style.display = "flex"; ctrls.style.gap = "8px"; ctrls.style.marginTop = "12px";
        const clearBtn = document.createElement("button"); clearBtn.className = "btn"; clearBtn.textContent = "Clear";
        const backBtn = document.createElement("button"); backBtn.className = "btn"; backBtn.textContent = "âŒ«";
        const goBtn = document.createElement("button"); goBtn.className = "btn"; goBtn.textContent = "Go"; goBtn.disabled = true;
        ctrls.append(clearBtn, backBtn, goBtn); host.appendChild(ctrls);

        const prog = document.createElement("div");
        prog.className = "muted"; prog.style.marginTop = "4px"; host.appendChild(prog);

        // ---- State ----
        let round = 0;
        let picksSym = [];
        let inputEnabled = false;
        let lockedRound = false; // prevents double-advance on very quick double taps

        function doorEl(symbol, isPhantom) {
          const d = document.createElement("div");
          d.className = "vf-cell";
          d.style.display = "flex"; d.style.alignItems = "center"; d.style.justifyContent = "center";
          d.style.fontSize = "28px"; d.style.position = "relative";
          if (isPhantom) {
            const tag = document.createElement("div");
            tag.textContent = "â–¢"; tag.style.position = "absolute"; tag.style.right = "10px"; tag.style.top = "8px"; tag.style.opacity = ".35";
            d.appendChild(tag);
          }
          const span = document.createElement("span"); span.textContent = symbol; d.appendChild(span);
          return d;
        }

        function renderCorridor() {
          corridor.innerHTML = "";

          // pos -> symbol index mapping for this round
          const p2s = posToSym(round).slice(); // copy so we can defensively adjust
          let wantSymIdx = Number(seqSymIdx[Math.min(round, rounds - 1)]);

          // --- GUARANTEE the target exists on the board ---
          // If the computed target symbol isn't present, try interpreting today's
          // stored value as a *position* for this round; else force-place it.
          if (!p2s.includes(wantSymIdx)) {
            const sv = stored[round];
            if (sv != null && !Number.isNaN(sv) && sv >= 0 && sv < p2s.length) {
              wantSymIdx = p2s[sv]; // treat stored as a position â†’ symbol index
            }
          }
          if (!p2s.includes(wantSymIdx)) {
            // final safety: swap the last slot to the target symbol
            p2s[p2s.length - 1] = wantSymIdx;
          }

          // Avoid the target being a phantom door (would make round impossible)
          const phantomOrig = Number(phantoms[round] ?? -1);
          const posTarget = p2s.indexOf(wantSymIdx);
          const phantomPos = (phantomOrig === posTarget) ? -1 : phantomOrig;

          for (let pos = 0; pos < p2s.length; pos++) {
            const symIdx = p2s[pos];
            const sym = symbols[symIdx];
            const isPhantom = (pos === phantomPos);

            const d = doorEl(sym, isPhantom);
            d.dataset.pos = String(pos);
            d.dataset.symi = String(symIdx);

            d.onclick = () => {
              if (!inputEnabled) return;

              if (isPhantom) {
                d.style.transition = "opacity 200ms ease";
                d.style.opacity = "0.28";
                d.classList.add("flash"); setTimeout(() => d.classList.remove("flash"), 140);
                return;
              }

              if (symIdx === wantSymIdx) {
                picksSym.push(symIdx);
                d.style.boxShadow = "0 0 12px rgba(80,255,180,.9)";
                setTimeout(() => (d.style.boxShadow = ""), 260);

                round++;
                goBtn.disabled = picksSym.length !== rounds;
                if (round < rounds) { renderCorridor(); updateProg(); }
                else { updateProg(); }
              } else {
                d.classList.add("flash"); setTimeout(() => d.classList.remove("flash"), 140);
              }
            };

            corridor.appendChild(d);
          }
        }

        function updateProg() {
          const glyph = symbols[seqSymIdx[Math.min(round, rounds - 1)]] ?? "?";
          prog.textContent = `round ${Math.min(round + 1, rounds)}/${rounds} â€¢ target ${glyph}`;
        }

        function replaySequence() {
          seqWrap.innerHTML = "";
          const items = seqSymIdx.map(i => {
            const el = document.createElement("div");
            el.textContent = symbols[i] ?? "?";
            el.style.padding = "2px 6px"; el.style.borderRadius = "8px";
            el.style.opacity = ".16"; el.style.transition = "opacity 140ms ease";
            seqWrap.appendChild(el);
            return el;
          });
          let t = 0;
          items.forEach((el) => { setTimeout(() => { el.style.opacity = "1"; }, t); t += Math.max(220, Math.floor(tempo * 0.55)); });
        }

        const startRound = () => { replaySequence(); inputEnabled = true; round = 0; picksSym = []; lockedRound = false; renderCorridor(); updateProg(); };
        showBtn.addEventListener("click", startRound);

        clearBtn.onclick = () => { picksSym = []; round = 0; inputEnabled = false; lockedRound = false; renderCorridor(); updateProg(); };
        backBtn.onclick = () => { if (!inputEnabled || !picksSym.length) return; picksSym.pop(); round = Math.max(0, round - 1); lockedRound = false; renderCorridor(); updateProg(); };

        goBtn.onclick = () => {
          // Prefer submitting POSITIONS if they match stored; else SYMBOLS; else POSITIONS.
          const picksPos = picksSym.map((sym, r) => symToPos(r)[sym]);
          const samePos = (stored.length === rounds) && stored.every((v, i) => v === picksPos[i]);
          const sameSym = (stored.length === rounds) && stored.every((v, i) => v === picksSym[i]);
          const payload = samePos ? picksPos : (sameSym ? picksSym : picksPos);
          submitAnswer(mini, payload.join(","));
        };

        renderCorridor();
        updateProg();
        setTimeout(startRound, 220);
      }

      // C â€¢ Pressure Chamber  â€” survival mode (keep all valves under for 10s)
      function mountPressureChamber(host, mini) {
        const ui = mini.ui || mini.ui_spec || {};
        const valves = (ui.valves || [
          { label: "A", base: 0.22, var: 0.08, reset_ms: 900, phase: 0.00 },
          { label: "B", base: 0.27, var: 0.09, reset_ms: 800, phase: 0.20 },
          { label: "C", base: 0.19, var: 0.07, reset_ms: 1100, phase: 0.50 },
          { label: "D", base: 0.26, var: 0.10, reset_ms: 850, phase: 0.10 },
        ]);
        const threshold = Number(ui.threshold || 1.0);

        // NEW: 10-second survival timer
        const SURVIVE_MS = Number(ui.survive_ms || 10000);

        // ---- UI scaffolding ----
        const header = document.createElement("div");
        header.className = "muted";
        header.textContent = `survive: ${(SURVIVE_MS / 1000).toFixed(1)}s`;
        host.appendChild(header);

        const barWrap = document.createElement("div");
        barWrap.style.display = "grid";
        barWrap.style.gridTemplateColumns = `repeat(${valves.length}, 1fr)`;
        barWrap.style.gap = "18px";
        barWrap.style.marginTop = "12px";
        host.appendChild(barWrap);

        const controls = document.createElement("div");
        controls.style.display = "flex";
        controls.style.gap = "10px";
        controls.style.marginTop = "14px";
        const startBtn = document.createElement("button");
        startBtn.className = "btn";
        startBtn.textContent = "â†» Start";
        controls.appendChild(startBtn);
        host.appendChild(controls);

        // ---- Bars + state ----
        const bars = [];
        const labels = [];
        const levels = valves.map(v => Math.max(0, 0.15 + (v.phase || 0) * 0.2)); // initial fill varies with phase
        let running = false;
        let tStart = 0;
        let timeLeft = SURVIVE_MS;
        let rafId = 0;

        valves.forEach((v, i) => {
          const col = document.createElement("div");
          col.style.display = "flex";
          col.style.flexDirection = "column";
          col.style.alignItems = "center";
          col.style.gap = "8px";

          const tube = document.createElement("div");
          tube.style.width = "90px";
          tube.style.height = "220px";
          tube.style.border = "2px solid rgba(180,200,255,.25)";
          tube.style.borderRadius = "10px";
          tube.style.position = "relative";
          tube.style.overflow = "hidden";
          tube.style.background = "linear-gradient(#10233a,#0b1a2a)";

          const fill = document.createElement("div");
          fill.style.position = "absolute";
          fill.style.left = "0";
          fill.style.bottom = "0";
          fill.style.width = "100%";
          fill.style.height = "0%";
          fill.style.transition = "height 60ms linear";
          fill.style.background = "linear-gradient(#f58475,#e55746)";
          tube.appendChild(fill);

          const btn = document.createElement("button");
          btn.className = "btn";
          btn.style.width = "90px";
          btn.textContent = v.label || String.fromCharCode(65 + i);
          btn.onclick = () => {
            if (!running) return;
            // tap drops pressure and gives a tiny grace window (reset_ms)
            const drop = 0.45 + Math.min(0.35, (v.var || 0.08));
            levels[i] = Math.max(0, levels[i] - drop);
            // visual thump
            fill.style.boxShadow = "0 0 10px rgba(120,220,255,.6) inset";
            setTimeout(() => (fill.style.boxShadow = ""), 120);
          };

          bars.push(fill);
          labels.push(btn);
          col.appendChild(tube);
          col.appendChild(btn);
          barWrap.appendChild(col);
        });

        // ---- Sim loop ----
        function setRunning(on) {
          running = on;
          startBtn.disabled = on;
          labels.forEach(b => (b.disabled = !on));
        }

        function paint() {
          for (let i = 0; i < bars.length; i++) {
            const pct = Math.max(0, Math.min(1, levels[i] / threshold));
            bars[i].style.height = `${Math.floor(pct * 100)}%`;
          }
          header.textContent = `survive: ${(Math.max(0, timeLeft) / 1000).toFixed(1)}s`;
        }

        function fail() {
          cancelAnimationFrame(rafId);
          setRunning(false);
          header.textContent = "overflowed â€” try again";
          // shake the whole area a bit
          host.classList.add("flash");
          setTimeout(() => host.classList.remove("flash"), 200);
        }

        function win() {
          cancelAnimationFrame(rafId);
          setRunning(false);
          header.textContent = "âœ” survived!";
          // Mark this mini complete and notify the page
          submitAnswer(mini, "success");
          try {
            window.dispatchEvent(new CustomEvent("escape-mini-complete", { detail: { id: mini.id || "pressure_chamber" } }));
          } catch (_) { }
        }

        function tick(ts) {
          if (!tStart) tStart = ts;
          const dt = Math.min(48, ts - (tick._last || ts)); // clamp delta
          tick._last = ts;

          // progress time
          timeLeft = SURVIVE_MS - (ts - tStart);
          if (timeLeft <= 0) {
            paint();
            return win();
          }

          // advance each valve
          for (let i = 0; i < valves.length; i++) {
            const v = valves[i];
            // deterministic rise speed per valve
            const speed = (v.base || 0.22) + (v.var || 0.08) * 0.6;
            levels[i] += speed * (dt / (v.reset_ms || 900)); // normalized by reset
            if (levels[i] >= threshold) {
              return fail();
            }
          }

          paint();
          rafId = requestAnimationFrame(tick);
        }

        (function () {
          // Capture start time once per page load (used by /api/finish)
          if (!window.__escapeStartedMs) window.__escapeStartedMs = Date.now();

          // Track completed minis and finish the run when all are done
          window.__escapeMiniDone = window.__escapeMiniDone || new Set();

          async function maybeFinishRun() {
            // We assume 3 minis per day. If you add/remove minis, adjust this number.
            const TOTAL_MINIS = 3;
            if (window.__escapeMiniDone.size < TOTAL_MINIS) return;
            if (window.__escapeRunFinished) return;
            window.__escapeRunFinished = true;

            // Stop any header clock if the page exposed it
            try { if (window.__escapeClock) clearInterval(window.__escapeClock); } catch (_) { }

            // Best-effort date key discovery
            const el = document.querySelector("[data-date-key]") || document.querySelector("#play-root");
            const dateKey = (el && (el.getAttribute("data-date-key") || el.dataset.dateKey)) || "";

            // Post finish (success) so you show up on the leaderboard
            try {
              await fetch("/escape/api/finish", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  date_key: dateKey,
                  started_ms: window.__escapeStartedMs,
                  success: true,
                  meta: {}
                })
              });
            } catch (_) { }
          }

          // When any mini completes, record it and try to finish the run
          window.addEventListener("escape-mini-complete", (ev) => {
            const id = (ev && ev.detail && ev.detail.id) || "unknown";
            window.__escapeMiniDone.add(id);
            maybeFinishRun();
          });
        })();

        function start() {
          // reset state
          for (let i = 0; i < levels.length; i++) {
            const v = valves[i];
            levels[i] = Math.max(0, 0.15 + (v.phase || 0) * 0.2);
          }
          timeLeft = SURVIVE_MS;
          tick._last = 0;
          tStart = 0;
          paint();
          setRunning(true);
          rafId = requestAnimationFrame(tick);
        }

        startBtn.onclick = start;

        // initial paint
        paint();
      }

    })();
  </script>

</body>

</html>