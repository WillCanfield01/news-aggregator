{# app/templates/escape/play.html (REWRITE) #}
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Daily Escape â€” Play</title>
  <style>
    :root {
      --bg: #0e1222;
      --panel: #151a2f;
      --panel2: #0f1427;
      --text: #f5f6fa;
      --muted: #99a3c7;
      --accent: #58bbff;
      --ok: #68f2a1;
      --warn: #ffd166;
      --bad: #ff6b6b;
      --shadow: rgba(0, 0, 0, 0.45);
      --card: #121832;
      --line: #223057;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 50% -20%, #1a1f3e 0%, #0e1222 55%, #0e1222 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .wrap {
      width: 100%;
      max-width: 820px;
      padding: 18px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 12px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
    }

    .brand {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .meta {
      color: var(--muted);
      font-size: 14px;
    }

    .progress {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
      margin-top: 10px;
    }

    .step {
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 8px 10px;
      text-align: center;
      font-size: 14px;
      color: var(--muted);
    }

    .step.active {
      color: var(--text);
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent) inset;
    }

    .panel {
      margin-top: 14px;
      background: linear-gradient(180deg, var(--panel), var(--panel2));
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 10px 30px var(--shadow);
      padding: 12px;
    }

    .center {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn {
      appearance: none;
      background: var(--accent);
      color: #08111e;
      border: none;
      border-radius: 12px;
      padding: 10px 14px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 6px 18px rgba(88, 187, 255, 0.35);
    }

    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .muted {
      color: var(--muted);
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .timer {
      font-weight: 800;
      letter-spacing: 0.4px;
    }

    .ads {
      margin-top: 12px;
      height: 64px;
      border: 1px dashed var(--line);
      border-radius: 12px;
      color: var(--muted);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .share {
      white-space: pre;
      background: #0b1225;
      padding: 8px 10px;
      border: 1px solid var(--line);
      border-radius: 8px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    /* Vault Frenzy UI */
    .vf-grid {
      display: grid;
      gap: 10px;
      touch-action: manipulation;
    }

    .vf-cell {
      width: 86px;
      height: 86px;
      border-radius: 14px;
      background: #121832;
      border: 1px solid #223057;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      cursor: pointer;
      user-select: none;
      transition: transform .06s ease;
    }

    .vf-cell.flash {
      transform: scale(1.04);
      transition: transform .08s;
    }

    .vf-cell:active {
      transform: scale(0.96);
    }

    /* Light Reactor UI */
    .reactor {
      position: relative;
      width: 320px;
      height: 320px;
      border-radius: 50%;
      background: #0e1a34;
      border: 2px solid #20335f;
      box-shadow: inset 0 0 60px rgba(32, 64, 128, .45);
    }

    .reactor .target {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 280px;
      height: 280px;
      margin: -140px 0 0 -140px;
      border-radius: 50%;
      border: 2px dashed #2954a8;
    }

    .reactor .orb {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #58bbff;
      box-shadow: 0 0 14px rgba(88, 187, 255, .9);
    }

    .reactor .zone {
      position: absolute;
      width: 260px;
      height: 260px;
      margin: -130px 0 0 -130px;
      top: 50%;
      left: 50%;
      border-radius: 50%;
      border: 4px solid rgba(104, 242, 161, .45);
    }

    .reactor .cta {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Pressure Chamber UI */
    .pc-wrap {
      display: flex;
      gap: 12px;
    }

    .pc-valve {
      width: 70px;
      background: #0f1a33;
      border: 1px solid #223057;
      border-radius: 10px;
      padding: 6px;
    }

    .pc-gauge {
      height: 160px;
      background: linear-gradient(0deg, #1c2b5c, #14305a);
      border-radius: 6px;
      overflow: hidden;
      position: relative;
    }

    .pc-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0%;
      background: linear-gradient(180deg, #68f2a1, #2a7f55);
      box-shadow: inset 0 0 18px rgba(0, 0, 0, .35);
      transition: height .12s linear;
    }

    .pc-btn {
      margin-top: 6px;
      width: 100%;
      font-weight: 700;
    }

    /* Finish */
    .finish {
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <div class="brand">Daily Escape</div>
        <div class="meta"><span id="todayMeta"></span> â€¢ <span class="timer" id="globalTimer">0:00</span></div>
      </div>
      <div class="row">
        <button id="muteBtn" class="btn" style="background:#263a5f;color:#cfe2ff">ðŸ”‡ Sound</button>
        <a href="/escape/leaderboard" class="btn" style="background:#1cf29f;">Leaderboard</a>
      </div>
    </header>

    <div class="progress">
      <div class="step active" id="stepA">â—† Vault Frenzy</div>
      <div class="step" id="stepB">â—Ž Phantom Doors</div>
      <div class="step" id="stepC">âœ¶ Pressure Chamber</div>
    </div>

    <div class="panel" id="panel">
      <div id="intro" class="center" style="flex-direction:column; padding:20px;">
        <h2 style="margin:4px 0 10px;">Ready to escape?</h2>
        <p class="muted" style="text-align:center; max-width:520px;">
          Three quick minigames. One escape. Finish as fast as you can.
        </p>
        <div class="ads">Ad slot</div>
        <div style="height:8px;"></div>
        <button id="startBtn" class="btn">Start</button>
      </div>

      <div id="gameA" style="display:none;"></div>
      <div id="gameB" style="display:none;"></div>
      <div id="gameC" style="display:none;"></div>

      <div id="finish" class="finish" style="display:none;">
        <h2>Escaped!</h2>
        <p>Total time: <b><span id="totalMs"></span> ms</b></p>
        <div class="row center" style="justify-content:center;">
          <div id="shareBlock" class="share"></div>
        </div>
        <div style="height:10px;"></div>
        <a href="/escape/leaderboard" class="btn">See Leaderboard</a>
      </div>
    </div>
  </div>

  <script>
    (function () {
      // ---------- utils ----------
      const $ = (s) => document.querySelector(s);
      const todayISO = () => new Date().toISOString().slice(0, 10);
      const qs = new URLSearchParams(location.search);

      // Mulberry32: simple seeded PRNG
      function m32(seed) { return function () { seed |= 0; seed = (seed + 0x6D2B79F5) | 0; let t = Math.imul(seed ^ (seed >>> 15), 1 | seed); t ^= t + Math.imul(t ^ (t >>> 7), 61 | t); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }; }
      function choice(rng, arr) { return arr[Math.floor(rng() * arr.length)] }

      const state = {
        dateKey: qs.get("date") || todayISO(),
        minis: [],
        current: 0,
        startedMs: null,
        soundOn: (localStorage.getItem("escape_sound") || "on") === "on",
        answers: {} // puzzleId -> string
      };

      document.addEventListener("DOMContentLoaded", init);

      async function init() {
        await fetchMinis();
        // header
        $("#todayMeta").textContent = `${state.dateKey} â€¢ ${state.theme || 'Daily Escape'}`;
        $("#startBtn").onclick = startRun;
        $("#muteBtn").onclick = () => {
          state.soundOn = !state.soundOn;
          localStorage.setItem("escape_sound", state.soundOn ? "on" : "off");
          $("#muteBtn").textContent = state.soundOn ? "ðŸ”Š Sound" : "ðŸ”‡ Sound";
        };
      }

      async function fetchMinis() {
        const res = await fetch(`/escape/api/today?format=minis&date=${encodeURIComponent(state.dateKey)}`);
        if (!res.ok) throw new Error("today fetch failed");
        const data = await res.json();
        state.theme = data.theme;
        state.minis = (data.minigames || []).map(m => ({
          slot: m.slot || m.id,
          // keep both for clarity
          puzzle_id: m.puzzle_id || m.id,
          id: m.puzzle_id || m.id,
          mechanic: (m.mechanic || (m.ui || {}).kind || "").toLowerCase(),
          prompt: m.prompt || "",
          ui: m.ui_spec || m.ui || {},
          // <â€” retain solution so Phantom Doors can see what the server expects
          solution: m.solution || null
        }));
      }

      // ---------- flow ----------
      function startRun() {
        state.startedMs = Date.now();
        $("#intro").style.display = "none";
        showCurrent();
      }

      function showCurrent() {
        const containers = ["#gameA", "#gameB", "#gameC"].map($);
        containers.forEach((el, i) => el.style.display = (i === state.current) ? "block" : "none");

        // Update the header tabs' active state
        ["#stepA", "#stepB", "#stepC"].forEach((sel, i) => {
          const el = $(sel);
          if (el) el.classList.toggle("active", i === state.current);
        });

        const mini = state.minis[state.current];
        const host = containers[state.current];
        host.innerHTML = "";

        // shared header
        const titles = ["A", "B", "C"];
        const h = document.createElement("div");
        h.innerHTML = `<h3 style="margin:6px 0 8px;">${titles[state.current]} â€¢ ${titleFor(mini)}</h3>
                       <p class="muted" style="max-width:780px">${mini.prompt}</p>`;
        host.appendChild(h);

        if (mini.mechanic === "vault_frenzy") mountVaultFrenzy(host, mini);
        else if (mini.mechanic === "phantom_doors") mountPhantomDoors(host, mini);
        else if (mini.mechanic === "pressure_chamber") mountPressureChamber(host, mini);
        else host.innerHTML += `<p>Unsupported mini: ${mini.mechanic}</p>`;
      }

      function titleFor(mini) {
        return mini.mechanic === "vault_frenzy" ? "Vault Frenzy" :
          mini.mechanic === "phantom_doors" ? "Phantom Doors" :
            mini.mechanic === "pressure_chamber" ? "Pressure Chamber" : "Puzzle";
      }

      async function submitAnswer(mini, answerStr) {
        // send the REAL saved id the server verifies against
        const body = {
          date_key: state.dateKey,           // keep for server
          date: state.dateKey,               // also send 'date' for tolerance
          puzzle_id: mini.puzzle_id || mini.id,
          answer: answerStr
        };
        const res = await fetch("/escape/api/submit", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        const data = await res.json();
        if (data && data.correct) {
          advance();
        } else {
          // soft fail
          flash(hostOf(mini), "#ff6b6b");
        }
      }

      function advance() {
        if (state.current < 2) { state.current += 1; showCurrent(); return; }
        finishRun(true);
      }

      async function finishRun(success) {
        const body = {
          date_key: state.dateKey,
          started_ms: state.startedMs,
          success,
          meta: {}
        };
        await fetch("/escape/api/finish", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        // show finish UI
        ["#gameA", "#gameB", "#gameC"].forEach(sel => $(sel).style.display = "none");
        $("#finish").style.display = "block";
        $("#totalMs").textContent = (Date.now() - state.startedMs);
        $("#shareBlock").textContent = `Daily Escape ${state.dateKey}\n${Object.keys(state.answers).length}/3 cleared`;
      }

      function hostOf(mini) {
        return [$("#gameA"), $("#gameB"), $("#gameC")][state.current];
      }

      function flash(el, color = "#68f2a1") { el.style.boxShadow = `0 0 0 2px ${color}`; setTimeout(() => el.style.boxShadow = "", 220); }

      // ---------- Minis ----------
      function mountVaultFrenzy(host, mini) {
        const ui = mini.ui || {};
        // normalize grid from ui_spec (server sends grid_rows/grid_cols)
        const g = {
          rows: (ui.grid && ui.grid.rows) || ui.grid_rows || 4,
          cols: (ui.grid && ui.grid.cols) || ui.grid_cols || 4
        };
        const tempo = ui.tempo_ms || 520;

        // ---- USE SERVER DATA (deterministic + refreshes after regen)
        // true_indices define the exact ordered solution; decoys can be shown anywhere.
        const trueIdx = (ui.true_indices || []).slice();
        const decoyIdx = (ui.decoy_indices || []).slice();

        const idxToRC = (i) => `${Math.floor(i / g.cols)}-${i % g.cols}`;
        const trueSeq = trueIdx.map(idxToRC); // expected tap order (matches server)

        // --- help
        const help = document.createElement("div");
        help.className = "muted";
        help.style.margin = "6px 0 12px";
        help.innerHTML =
          "Watch the pattern once, then tap back the <b>true</b> flashes in order. " +
          "True flashes highlight <b>green</b>; decoys are red and are ignored. " +
          "Press <b>Play</b> to see it again (resets your input).";
        host.appendChild(help);

        // --- grid
        const grid = document.createElement("div");
        grid.className = "vf-grid";
        grid.style.gridTemplateColumns = `repeat(${g.cols}, 86px)`;
        const cells = [];
        for (let r = 0; r < g.rows; r++) {
          for (let c = 0; c < g.cols; c++) {
            const cell = document.createElement("div");
            cell.className = "vf-cell";
            cell.dataset.rc = `${r}-${c}`;
            grid.appendChild(cell);
            cells.push(cell);
          }
        }
        host.appendChild(grid);

        // --- controls
        const ctrls = document.createElement("div");
        ctrls.style.display = "flex"; ctrls.style.gap = "8px"; ctrls.style.marginTop = "10px";
        const playBtn = btn("â–¶ Play", () => startPlayback(true));
        const clearBtn = btn("Clear", resetInput);
        const backBtn = btn("âŒ«", () => { if (!inputEnabled) return; picks.pop(); updateProgress(); redrawSelections(); });
        // Submit indices so it matches any server canonicalization path
        const goBtn = btn("Go", () => {
          const answer = picks.map(rc => {
            const [r, c] = rc.split("-").map(Number);
            return (r * g.cols + c);
          }).join(",");
          submitAnswer(mini, answer);
        });
        goBtn.disabled = true;
        ctrls.append(playBtn, clearBtn, backBtn, goBtn);
        host.appendChild(ctrls);

        const prog = document.createElement("div");
        prog.className = "muted"; prog.style.marginTop = "4px";
        host.appendChild(prog);

        function btn(t, fn) { const b = document.createElement("button"); b.className = "btn"; b.textContent = t; b.onclick = fn; return b; }

        // === Build the playback event timeline from server indices ===
        // We interleave decoys at a couple of fixed slots; solution order is still trueSeq.
        const events = [];
        const decoySlots = decoyIdx.length === 2 ? [1, 4] : (decoyIdx.length === 1 ? [2] : []);
        let d = 0;
        for (let i = 0; i < trueIdx.length; i++) {
          if (decoySlots.includes(i) && d < decoyIdx.length) {
            const di = decoyIdx[d++]; events.push({ r: Math.floor(di / g.cols), c: (di % g.cols), isDecoy: true, dbl: true, delay: false });
          }
          const ti = trueIdx[i]; events.push({ r: Math.floor(ti / g.cols), c: (ti % g.cols), isDecoy: false, dbl: false, delay: false });
        }
        while (d < decoyIdx.length) {
          const di = decoyIdx[d++]; events.push({ r: Math.floor(di / g.cols), c: (di % g.cols), isDecoy: true, dbl: true, delay: false });
        }

        // Input state (post-playback)
        let inputEnabled = false;
        let picks = [];
        updateProgress();

        // Cell visuals
        function setFlash(cell, color, on) {
          if (on) {
            cell.style.outline = `2px solid ${color}`;
            cell.style.background = (color === "#6bf2a9") ? "#1e2a54" : "#2a1e27";
          } else {
            cell.style.outline = "";
            cell.style.background = "";
          }
        }
        function flashCell(cell, color, onMs) {
          setFlash(cell, color, true);
          setTimeout(() => setFlash(cell, color, false), onMs);
        }
        function redrawSelections() {
          cells.forEach(c => c.style.boxShadow = "");
          picks.forEach((rc) => {
            const [r, c] = rc.split("-").map(Number);
            const el = cells[r * g.cols + c];
            el.style.boxShadow = "0 0 0 2px rgba(107,242,169,.65) inset";
          });
        }

        // Allow any taps; server verifies the ordered sequence.
        grid.onclick = (ev) => {
          if (!inputEnabled) return;
          const cell = ev.target.closest(".vf-cell");
          if (!cell) return;
          const rc = cell.dataset.rc;

          if (picks.length >= trueSeq.length) return;  // don't overrun
          picks.push(rc);
          updateProgress();
          redrawSelections();

          // subtle feedback if not the expected next cell
          const need = trueSeq[picks.length - 1];
          if (rc !== need) {
            cell.classList.add("flash");
            setTimeout(() => cell.classList.remove("flash"), 120);
          }

          if (picks.length === trueSeq.length) goBtn.disabled = false;
        };

        function updateProgress() {
          prog.textContent = `taps ${picks.length}/${trueSeq.length}`;
          goBtn.disabled = (picks.length !== trueSeq.length);
        }
        function resetInput() {
          if (!inputEnabled) return;
          picks = [];
          updateProgress();
          redrawSelections();
        }

        // Playback: show full pattern; decoys flash red, trues green
        function startPlayback(reset) {
          let __clockStarted = false;
          function startClock() {
            if (__clockStarted) return;
            __clockStarted = true;
            const label = document.getElementById("globalTimer"); // â† was #escape-elapsed
            if (!label) return;
            const t0 = Date.now();
            const fmt = s => `${Math.floor(s / 60)}:${String(s % 60).padStart(2, "0")}`;
            setInterval(() => {
              const s = Math.floor((Date.now() - t0) / 1000);
              label.textContent = fmt(s);
            }, 1000);
          }
          inputEnabled = false;
          if (reset) { picks = []; updateProgress(); redrawSelections(); }

          // Start the clock on first playback
          startClock();

          cells.forEach(c => setFlash(c, "#000", false));
          let t = 0;
          const onMs = Math.floor(tempo * 0.6);

          events.forEach(ev => {
            const cell = cells[ev.r * g.cols + ev.c];
            const show = () => flashCell(cell, ev.isDecoy ? "#ff6b6b" : "#6bf2a9", onMs);
            setTimeout(() => {
              show();
              if (ev.dbl) setTimeout(show, Math.floor(onMs * 0.8));
            }, t);
            t += tempo;
          });

          // enable input after the final flash
          setTimeout(() => { inputEnabled = true; }, t + 30);
        }

        // auto-play once so the player sees the pattern
        setTimeout(() => startPlayback(false), 200);
      }

      function mountPhantomDoors(host, mini) {
        // ---- Server payload ----
        const ui = mini.ui || {};
        const symbols = (ui.symbols || ["â–²", "â—", "â—†", "â– ", "âœ¶", "âœ¦"]).slice();   // 6 symbols
        const rounds = Number(ui.rounds || 3);
        const shuffles = (ui.shuffles || []).map(a => a.slice());               // [[perm]...], perm[pos] = symIdx
        const phantoms = (ui.phantoms || Array(rounds).fill(-1)).slice();       // [phantomPos per round]
        const tempo = Number(ui.tempo_ms || 600);

        // Raw answer from server (e.g. "2,4,0"). Could be POSITIONS or SYMBOL INDICES.
        const stored = (mini.solution && mini.solution.answer)
          ? String(mini.solution.answer).split(",").map(x => parseInt(x, 10))
          : [];

        // Sequence (SYMBOL indices) to SHOW above the corridor:
        // 1) prefer ui.sequence (symbol indices)
        // 2) else map stored POSITIONS via each round's shuffle
        // 3) else treat stored as symbol indices
        let seqSymIdx = [];
        if (Array.isArray(ui.sequence) && ui.sequence.length) {
          seqSymIdx = ui.sequence.slice(0, rounds).map(Number);
        } else if (stored.length === rounds && (shuffles[0] || []).length) {
          seqSymIdx = stored.map((pos, r) => (shuffles[r] || [])[pos] ?? Number(pos));
        } else {
          seqSymIdx = stored.slice(0, rounds);
        }

        // ---- Layout ----
        const help = document.createElement("div");
        help.className = "muted";
        help.style.margin = "6px 0 12px";
        help.innerHTML = "Memorize the symbol sequence. Doors reshuffle each round. Avoid phantom doors (they fade)!";
        host.appendChild(help);

        // Sequence strip
        const seqBar = document.createElement("div");
        seqBar.style.display = "flex";
        seqBar.style.gap = "10px";
        seqBar.style.alignItems = "center";
        seqBar.style.margin = "8px 0 14px";
        const showBtn = document.createElement("button");
        showBtn.className = "btn";
        showBtn.textContent = "â–¶ Show";
        seqBar.appendChild(showBtn);

        const seqWrap = document.createElement("div");
        seqWrap.style.display = "flex";
        seqWrap.style.gap = "8px";
        seqWrap.style.fontSize = "20px";
        seqWrap.style.opacity = "0.85";
        seqBar.appendChild(seqWrap);
        host.appendChild(seqBar);

        // Doors (6) laid out 3Ã—2
        const corridor = document.createElement("div");
        corridor.style.display = "grid";
        corridor.style.gridTemplateColumns = "repeat(3, 220px)";
        corridor.style.gridAutoRows = "86px";
        corridor.style.gap = "18px";
        host.appendChild(corridor);

        // Controls
        const ctrls = document.createElement("div");
        ctrls.style.display = "flex";
        ctrls.style.gap = "8px";
        ctrls.style.marginTop = "12px";
        const clearBtn = document.createElement("button"); clearBtn.className = "btn"; clearBtn.textContent = "Clear";
        const backBtn = document.createElement("button"); backBtn.className = "btn"; backBtn.textContent = "âŒ«";
        const goBtn = document.createElement("button"); goBtn.className = "btn"; goBtn.textContent = "Go"; goBtn.disabled = true;
        ctrls.append(clearBtn, backBtn, goBtn);
        host.appendChild(ctrlls);

        const prog = document.createElement("div");
        prog.className = "muted";
        prog.style.marginTop = "4px";
        host.appendChild(prog);

        // ---- State ----
        let round = 0;                 // 0..rounds-1
        let picksSym = [];             // chosen SYMBOL indices per round
        let inputEnabled = false;

        // helpers
        function doorEl(symbol, isPhantom) {
          const d = document.createElement("div");
          d.className = "vf-cell";
          d.style.display = "flex";
          d.style.alignItems = "center";
          d.style.justifyContent = "center";
          d.style.fontSize = "28px";
          d.style.position = "relative";
          if (isPhantom) {
            const tag = document.createElement("div");
            tag.textContent = "â–¢";
            tag.style.position = "absolute";
            tag.style.right = "10px";
            tag.style.top = "8px";
            tag.style.opacity = ".35";
            d.appendChild(tag);
          }
          const span = document.createElement("span");
          span.textContent = symbol;
          d.appendChild(span);
          return d;
        }

        function renderCorridor() {
          corridor.innerHTML = "";
          const perm = shuffles[round] || symbols.map((_, i) => i);
          const phantomPos = Number(phantoms[round] ?? -1);

          for (let pos = 0; pos < perm.length; pos++) {
            const symIdx = perm[pos];
            const sym = symbols[symIdx];
            const isPhantom = (pos === phantomPos);

            const d = doorEl(sym, isPhantom);
            d.dataset.pos = String(pos);
            d.dataset.symi = String(symIdx);

            d.onclick = () => {
              if (!inputEnabled) return;

              if (isPhantom) {
                // trick: only fades AFTER you tap it
                d.style.transition = "opacity 200ms ease";
                d.style.opacity = "0.28";
                d.classList.add("flash"); setTimeout(() => d.classList.remove("flash"), 140);
                return;
              }

              // Correct door for this round = door whose SYMBOL matches target
              const wantSymIdx = Number(seqSymIdx[round]);
              if (symIdx === wantSymIdx) {
                picksSym.push(symIdx);
                // reward glow
                d.style.boxShadow = "0 0 12px rgba(80,255,180,.9)";
                setTimeout(() => (d.style.boxShadow = ""), 260);

                round++;
                goBtn.disabled = picksSym.length !== rounds;
                if (round < rounds) {
                  renderCorridor();
                  updateProg();
                } else {
                  updateProg();
                }
              } else {
                d.classList.add("flash"); setTimeout(() => d.classList.remove("flash"), 140);
              }
            };

            corridor.appendChild(d);
          }
        }

        function updateProg() {
          const glyph = symbols[seqSymIdx[Math.min(round, rounds - 1)]] ?? "?";
          prog.textContent = `round ${Math.min(round + 1, rounds)}/${rounds} â€¢ target ${glyph}`;
        }

        function replaySequence() {
          seqWrap.innerHTML = "";
          const items = seqSymIdx.map(i => {
            const el = document.createElement("div");
            el.textContent = symbols[i] ?? "?";
            el.style.padding = "2px 6px";
            el.style.borderRadius = "8px";
            el.style.opacity = ".16";
            el.style.transition = "opacity 140ms ease";
            seqWrap.appendChild(el);
            return el;
          });
          // animate one by one for drama
          let t = 0;
          items.forEach((el) => {
            setTimeout(() => { el.style.opacity = "1"; }, t);
            t += Math.max(220, Math.floor(tempo * 0.55));
          });
        }

        // Control hooks
        showBtn.onclick = () => { replaySequence(); inputEnabled = true; round = 0; picksSym = []; renderCorridor(); updateProg(); };
        clearBtn.onclick = () => { picksSym = []; round = 0; inputEnabled = false; renderCorridor(); updateProg(); };
        backBtn.onclick = () => { if (!inputEnabled || !picksSym.length) return; picksSym.pop(); round = Math.max(0, round - 1); renderCorridor(); updateProg(); };
        goBtn.onclick = () => {
          // Compute both forms; submit whichever matches serverâ€™s stored format for the day.
          const picksPos = picksSym.map((sym, r) => (shuffles[r] || []).indexOf(sym));
          const storedLooksPos = (stored.length === rounds) && picksPos.every(p => p >= 0);
          const usePos = storedLooksPos && stored.join(",") === picksPos.join(",");
          submitAnswer(mini, (usePos ? picksPos : picksSym).join(","));
        };

        // initial paint + auto-show once
        renderCorridor();
        updateProg();
        setTimeout(() => showBtn.click(), 220);
      }

      // PRESSURE CHAMBER: animate gauges; accept a pre-computed order of labels
      function mountPressureChamber(host, mini) {
        const ui = mini.ui || {};
        const targetCount = ui.target_count || 8;
        let picks = [];

        // HUD (taps left + âŸ² Restart)
        const hud = document.createElement("div");
        hud.className = "muted"; hud.style.margin = "6px 0 12px";
        const left = document.createElement("span");
        const rst = document.createElement("button"); rst.className = "btn"; rst.textContent = "âŸ² Restart";
        hud.append(left, document.createTextNode(" "), rst);
        host.appendChild(hud);

        // Container for valves (this was missing in your file)
        const wrap = document.createElement("div");
        wrap.className = "pc-wrap";
        host.appendChild(wrap);

        const valves = (ui.valves || []).map(v => ({ ...v, level: 0 }));
        const rng = m32(ui.seed || 1);

        const buttons = [];
        valves.forEach((v) => {
          const col = document.createElement("div"); col.className = "pc-valve";
          const g = document.createElement("div"); g.className = "pc-gauge";
          const fill = document.createElement("div"); fill.className = "pc-fill";
          g.appendChild(fill);
          const b = document.createElement("button"); b.className = "btn pc-btn"; b.textContent = v.label;
          b.onclick = () => {
            picks.push(v.label);
            v.level = Math.max(0, v.level - 0.6); // drop pressure
            updateLeft();
            if (picks.length >= targetCount) submitAnswer(mini, picks.join(","));
          };
          col.appendChild(g); col.appendChild(b);
          wrap.appendChild(col);
          buttons.push({ fill, btn: b, valve: v });
        });

        function updateLeft() { left.textContent = `taps left: ${Math.max(0, targetCount - picks.length)}`; }
        updateLeft();

        rst.onclick = () => {
          picks = [];
          valves.forEach(v => v.level = 0);
          buttons.forEach(({ fill }) => (fill.style.height = "0%"));
          updateLeft();
        };

        const tickMs = ui.tempo_ms || 90;
        function frame() {
          buttons.forEach(({ fill, valve }) => {
            const drift = (valve.base || 0.2) + (rng() - 0.5) * (valve.var || 0.1);
            valve.level = Math.min(1.2, valve.level + Math.max(0.02, drift) * (tickMs / 1000));
            fill.style.height = Math.max(0, Math.min(100, valve.level * 100)) + "%";
            if (valve.level >= 1.0) {
              valve.level = 1.0;
              fill.style.background = "linear-gradient(180deg,#ff6b6b,#9b2e2e)"; // overflow warning
            }
          });
          setTimeout(frame, tickMs);
        }
        frame();
      }

    })();
  </script>

</body>

</html>