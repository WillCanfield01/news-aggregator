<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Mini Escape — {{ date_key }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <style>
        :root {
            --bg: #0f1220;
            --panel: #151a2f;
            --panel2: #0f1427;
            --text: #e6eaf6;
            --muted: #9aa3c7;
            --brand: #58bbff;
            --ok: #55d38e;
            --err: #ff6b6b;
            --shadow: rgba(0, 0, 0, .35);
            --vh: 1vh
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--text);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif
        }

        .wrap {
            max-width: 960px;
            margin: 0 auto;
            padding: 20px 16px 80px
        }

        header {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 12px
        }

        .title {
            font-size: 22px;
            font-weight: 800
        }

        .badge {
            padding: 4px 10px;
            border-radius: 999px;
            background: #172042;
            border: 1px solid #26325f;
            color: #b6c4ff
        }

        .timer {
            margin-left: auto;
            font-variant-numeric: tabular-nums;
            font-weight: 700;
            background: #172042;
            border: 1px solid #26325f;
            border-radius: 10px;
            padding: 6px 10px
        }

        .intro,
        .panel {
            background: linear-gradient(180deg, #151a2f, #0f1427);
            border: 1px solid #24305b;
            border-radius: 14px;
            box-shadow: 0 10px 30px var(--shadow)
        }

        .intro {
            padding: 14px;
            margin: 10px 0 14px
        }

        .row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        button,
        .btn {
            background: #1c2a4e;
            border: 1px solid #2a3c73;
            color: #cfe3ff;
            border-radius: 10px;
            padding: 10px 14px;
            cursor: pointer;
            text-decoration: none
        }

        button:hover,
        .btn:hover {
            filter: brightness(1.06)
        }

        input[type=text] {
            flex: 1;
            min-width: 200px;
            background: #0b1226;
            border: 1px solid #24305b;
            color: var(--text);
            border-radius: 10px;
            padding: 10px 12px
        }

        .scene {
            padding: 12px;
            margin: 10px 0;
            display: none
        }

        .scene.active {
            display: block
        }

        .scene h3 {
            margin: 4px 0 6px
        }

        .route-btns {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .p-card {
            margin-top: 8px;
            padding: 10px;
            background: #0f1427;
            border: 1px solid #22305d;
            border-radius: 12px
        }

        .status {
            font-size: 13px;
            color: var(--muted)
        }

        .status.ok {
            color: var(--ok)
        }

        .status.err {
            color: var(--err)
        }

        .hint-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 6px
        }

        .hint-pill {
            background: #0f1730;
            border: 1px dashed #2a3769;
            color: #a9b4e6;
            border-radius: 999px;
            padding: 6px 10px;
            cursor: pointer
        }

        .hint-text {
            margin-top: 4px;
            background: #0c1428;
            border: 1px solid #25305a;
            border-radius: 8px;
            padding: 8px 10px;
            display: none
        }

        .footer {
            margin-top: 16px;
            padding: 12px
        }

        .final {
            display: none
        }

        .notes {
            position: sticky;
            top: 10px
        }

        textarea {
            width: 100%;
            min-height: 140px;
            background: #0b1226;
            border: 1px solid #24305b;
            color: var(--text);
            border-radius: 10px;
            padding: 8px
        }

        .two-col {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 14px
        }

        @media (max-width:900px) {
            .two-col {
                grid-template-columns: 1fr
            }
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(7, 10, 18, .6);
            backdrop-filter: blur(6px);
            display: flex;
            align-items: flex-start;
            /* mobile: keep top-aligned */
            justify-content: center;
            z-index: 50;
            overflow: auto;
            /* <- allow scrolling */
            padding: 12px;
            /* breathing room */
        }

        .start {
            width: min(780px, 92vw);
            max-height: 92vh;
            /* <- ensure Start button stays reachable */
            overflow: auto;
            /* <- scroll inside if needed */
            background: linear-gradient(180deg, #141a30, #0f1427);
            border: 1px solid #24305b;
            border-radius: 20px;
            padding: 22px;
            box-shadow: 0 20px 60px var(--shadow)
        }

        .hidden {
            display: none !important
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #0e182e;
            color: #dce4ff;
            border: 1px solid #2c3a69;
            padding: 10px 12px;
            border-radius: 10px;
            box-shadow: 0 10px 30px var(--shadow);
            opacity: 0;
            transform: translateY(10px);
            transition: .2s;
            z-index: 60
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0)
        }

        .rules {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px
        }

        @media (max-width:700px) {
            .rules {
                grid-template-columns: 1fr
            }
        }

        .rule {
            background: #0f162d;
            border: 1px solid #24305b;
            border-radius: 12px;
            padding: 10px
        }

        .muted {
            color: #9aa3c7;
            font-size: 13px
        }

        .gloss {
            margin-top: 8px;
            background: #0b1327;
            border: 1px solid #243463;
            border-radius: 10px;
            padding: 8px
        }

        .gloss summary {
            cursor: pointer;
            color: #b6c4ff
        }

        .choice {
            display: inline-block;
            margin: 4px 6px 0 0;
            padding: 8px 10px;
            border-radius: 10px;
            background: #14234a;
            border: 1px solid #2a3c73;
            cursor: pointer;
            user-select: none
        }

        .choice.selected {
            outline: 2px solid var(--brand)
        }

        .chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px
        }

        .chip {
            padding: 6px 10px;
            border-radius: 999px;
            background: #132147;
            border: 1px solid #2a3c73;
            cursor: pointer;
            transition: transform .08s ease, box-shadow .08s ease, filter .08s ease;
            box-shadow: 0 2px 0 rgba(0, 0, 0, .25);
        }

        .chip:hover {
            filter: brightness(1.06)
        }

        .chip:active {
            transform: translateY(1px);
            box-shadow: 0 1px 0 rgba(0, 0, 0, .25)
        }

        /* Cue strip for sequence minis */
        .cue-strip {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px
        }

        .cue {
            padding: 6px 10px;
            border-radius: 10px;
            background: #1b2647;
            border: 1px solid #2a3c73;
            user-select: none;
            transition: transform .08s ease, box-shadow .08s ease, filter .08s ease;
            box-shadow: 0 2px 0 rgba(0, 0, 0, .25);
        }

        .cue.playing {
            outline: 2px solid var(--brand);
            filter: brightness(1.15);
            transform: translateY(-1px);
        }

        .grid {
            display: inline-grid;
            gap: 6px;
            margin-top: 6px
        }

        .grid .cell {
            min-width: 36px;
            min-height: 36px;
            padding: 6px 8px;
            text-align: center;
            border-radius: 8px;
            background: #0e1832;
            border: 1px solid #243463;
            cursor: pointer;
            user-select: none;
            font-variant-numeric: tabular-nums;
            transition: transform .06s ease
        }

        .grid .cell.on {
            outline: 2px solid var(--brand);
            transform: scale(1.03)
        }

        /* NEW: visually mark the start cell the generator provides */
        .grid .cell.start {
            outline: 2px solid var(--brand);
            box-shadow: 0 0 0 3px rgba(88, 187, 255, .2), 0 0 16px rgba(88, 187, 255, .25) inset;
            position: relative;
        }

        .grid .cell.start::after {
            content: "★";
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 12px;
            color: var(--brand);
        }

        .helper {
            font-size: 12px;
            color: #9aa3c7;
            margin-top: 6px
        }

        /* NEW: make disabled UI really inert */
        .disabled {
            opacity: .6;
            pointer-events: none;
            filter: saturate(.7);
        }

        /* AFTER: add near other button styles */
        .route-btn {
            text-align: left;
            min-width: 220px;
        }

        .route-title {
            font-weight: 700;
        }

        .route-sub {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px;
        }

        /* Thematic route buttons */
        .route-btn {
            text-align: left;
            min-width: 240px
        }

        .route-title {
            font-weight: 700
        }

        .route-sub {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-top: 2px
        }
    </style>
</head>

<body>
    <!-- Intro modal: scenario + rules. Timer starts only after click -->
    <div id="overlay" class="overlay">
        <div class="start">
            <div style="font-size:22px;font-weight:800;margin-bottom:6px;">Mini Escape — Daily Trail</div>
            <div id="ovTitle" style="font-weight:700;margin-top:2px;">Loading…</div>
            <div id="ovIntro" class="muted" style="margin-top:6px;">Please wait…</div>

            <div class="rules">
                <div class="rule">
                    <div style="font-weight:700;margin-bottom:4px;">How it works</div>
                    <div class="muted">Solve 3 scenes to collect fragments, then combine them — in order — to unlock the
                        final code.
                    </div>
                </div>

                <div class="rule">
                    <div style="font-weight:700;margin-bottom:4px;">Routes</div>
                    <div class="muted" id="ovRoutesText">
                        Each scene offers three scene-themed routes (1× / 2× / 3×). Faster routes delay hints (+30s /
                        +60s) and may
                        reward a clean first try.
                    </div>
                </div>

                <div class="rule">
                    <div style="font-weight:700;margin-bottom:4px;">Hints & timing</div>
                    <div class="muted">
                        Hints unlock after a short delay. Choosing faster routes delays hints a bit more (+30s for
                        quick, +60s for
                        risky). Finishing a scene on your first try without hints can earn a time bonus on brisk/risky
                        routes.
                    </div>
                </div>

                <div class="rule">
                    <div style="font-weight:700;margin-bottom:4px;">Tips</div>
                    <div class="muted">Notes save locally per day. Press <b>Cmd/Ctrl+Enter</b> to submit an answer
                        quickly.</div>
                </div>
            </div>
            <div class="row" style="justify-content:center;margin-top:12px;">
                <button id="startBtn" style="background:#1b7bc0;border-color:#2f8bd5">Start Today’s Escape</button>
                <a class="badge" href="/escape/leaderboard?date={{ date_key }}" target="_blank" rel="noopener">View
                    Leaderboard</a>
            </div>
            <div class="muted" style="margin-top:6px;">Date: <b id="ovDate">{{ date_key }}</b> • Difficulty: <b
                    id="ovDiff">{{ difficulty|default('medium')|title }}</b></div>
        </div>
    </div>

    <div class="wrap">
        <header>
            <div class="title">Mini Escape — <span id="dateKey">{{ date_key }}</span></div>
            <span class="badge">Difficulty: <b id="difficulty">{{ difficulty|default('medium')|title }}</b></span>
            <span class="badge" id="sceneBadge">Scene 1 of 3</span>
            <div id="timer" class="timer">00:00.000</div>
        </header>

        <div class="two-col">
            <main>
                <section class="intro panel">
                    <div id="roomTitle" style="font-weight:800;margin-bottom:6px;">Loading…</div>
                    <div id="roomIntro" style="color:#c8d4ff">Please wait…</div>
                </section>

                <!-- Scenes (sequential reveal) -->
                <section id="scenes"></section>

                <section class="footer panel final" id="finalGate">
                    <div><strong>Final Code</strong> — Combine the three fragments <em>in order</em> (Scene 1 +
                        Scene 2
                        + Scene 3).
                    </div>

                    <!-- NEW: live fragment display -->
                    <div id="fragBag" class="status" style="margin-top:6px;"></div>

                    <div class="row" style="margin-top:6px;">
                        <input id="finalInput" type="text" placeholder="Enter final code…" autocomplete="off" />
                        <button id="finishBtn">Finish & Submit Time</button>
                    </div>
                    <div id="finalStatus" class="status"></div>

                    <div id="share"
                        style="display:none;margin-top:10px;border:1px dashed #2a3769;border-radius:12px;padding:10px;color:#b6c4ff">
                        <div id="shareText">Share your time!</div>
                        <div class="row" style="margin-top:8px;">
                            <button id="copyBtn">Copy Result</button>
                            <a class="btn" href="/escape/leaderboard?date={{ date_key }}" target="_blank"
                                rel="noopener">View Leaderboard</a>
                        </div>
                    </div>
                </section>
            </main>

            <!-- Notes panel -->
            <aside class="notes">
                <div class="panel" style="padding:12px;">
                    <div style="font-weight:700;margin-bottom:6px;">Notes</div>
                    <textarea id="notesBox" placeholder="Jot down letters, codes, fragments…"></textarea>
                    <div class="row" style="margin-top:8px;">
                        <button id="clearNotes">Clear</button>
                        <span id="saveStamp" class="status" style="margin-left:auto;">Autosaved</span>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <div id="toast" class="toast">Saved</div>

    <script>
        // ----- Mobile viewport + scroll lock helpers -----
        function setVHVar() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
        }
        setVHVar();
        window.addEventListener('resize', setVHVar);
        window.addEventListener('orientationchange', setVHVar);

        const body = document.body;
        function lockScroll() {
            body.dataset.scrollY = String(window.scrollY);
            body.style.position = 'fixed';
            body.style.top = `-${body.dataset.scrollY}px`;
            body.style.left = '0';
            body.style.right = '0';
        }
        function unlockScroll() {
            const y = parseInt(body.dataset.scrollY || '0', 10);
            body.style.position = '';
            body.style.top = '';
            body.style.left = '';
            body.style.right = '';
            window.scrollTo(0, y);
        }

        // Modal is open by default → lock background scroll
        document.addEventListener('DOMContentLoaded', lockScroll);

        // ------- Glossary (legacy types) -------
        const GLOSSARY = {
            acrostic: {
                label: "What’s an acrostic?",
                text: "Read the FIRST letter of each line vertically to spell a single word."
            },
            tapcode: {
                label: "What’s tap code?",
                text: "Use a 5×5 Polybius square (I/J share a cell). Each pair like 3-2 is row-col."
            },
            pathcode: {
                label: "What’s a path code?",
                text: "Follow the given moves (R/D) on the grid from top-left, collecting letters."
            },
            mini: {
                label: "What’s a mini-game?",
                text: "A short, scene-themed challenge. Controls change daily: buttons, chips, grid, or text."
            }
        };
        const ROUTE_TO_APPROACH = { cautious: "observe", brisk: "listen", risky: "traverse" };
        // --- Thematic labeling fallback (client-side) ---
        const STOP = new Set(["the", "a", "an", "and", "of", "to", "in", "on", "at", "for", "with", "into", "across", "over", "under", "hall", "room", "scene", "chamber"]);
        function pickNoun(text = "") {
            const words = (text || "").toLowerCase().match(/[a-z]{4,}/g) || [];
            const w = words.find(w => !STOP.has(w)) || "device";
            return w;
        }
        function isGenericLabel(s = "") { return /^(proceed carefully|move quickly|take a risk)$/i.test(s.trim()); }
        function themedRouteCopy(rm, rid, route) {
            const noun = pickNoun(`${rm.title || ""} ${rm.text || ""}`);
            const mult = { cautious: "1×", brisk: "2×", risky: "3×" };
            const defaults = {
                cautious: { label: `Inspect the ${noun}`, sub: "Safer path — hints unlock sooner." },
                brisk: { label: `Weave past the ${noun}`, sub: "Faster path — hints unlock +30s; small time bonus if clean." },
                risky: { label: `Tamper with the ${noun}`, sub: "Bold path — hints unlock +60s; bigger bonus if first try." }
            };
            const fromApi = {
                label: (route.label && !isGenericLabel(route.label)) ? route.label : null,
                sub: route.sub || null
            };
            return {
                label: fromApi.label || defaults[rid].label,
                sub: fromApi.sub || defaults[rid].sub,
                mult: mult[rid] || "1×"
            };
        }

        // ------- State -------
        // AFTER
        const state = {
            dateKey: "{{ date_key }}",
            startedMs: null,
            tickHandle: null,
            room: null,
            currentScene: 0,
            solvedScenes: [false, false, false],
            chosenRoutes: [null, null, null],
            hintsUsedScene: [0, 0, 0],
            submissionsScene: [0, 0, 0],
            fragments: ["", "", ""],
            hintPolicy: { first_hint_delay_s: 60, second_hint_delay_s: 120 },
            miniAnswer: ["", "", ""],
            routeLocked: [false, false, false],
            // 👇 NEW — avoids runtime error in hint timers
            puzzleMountedAt: [0, 0, 0]
        };

        const $ = id => document.getElementById(id);
        const fmtTime = ms => {
            const m = Math.floor(ms / 60000), s = Math.floor((ms % 60000) / 1000), ms3 = String(ms % 1000).padStart(3, "0");
            return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}.${ms3}`;
        };
        function toast(msg) { const t = $("toast"); t.textContent = msg; t.classList.add("show"); setTimeout(() => t.classList.remove("show"), 1600); }

        // ------- Notes (localStorage per day) -------
        const NOTES_KEY = d => `trail-notes-${d}`;
        function loadNotes() { $("notesBox").value = localStorage.getItem(NOTES_KEY(state.dateKey)) || ""; }
        function saveNotes() { localStorage.setItem(NOTES_KEY(state.dateKey), $("notesBox").value); $("saveStamp").textContent = "Saved"; setTimeout(() => $("saveStamp").textContent = "Autosaved", 1000); }

        // ------- Prefetch room for intro modal -------
        window.addEventListener("DOMContentLoaded", async () => { await prefetchRoom(); loadNotes(); });

        async function prefetchRoom() {
            try {
                const res = await fetch(`/escape/api/today?date=${encodeURIComponent(state.dateKey)}`, { cache: "no-store" });
                const room = await res.json();
                state.room = room;
                state.hintPolicy = room.server_hint_policy || state.hintPolicy;
                $("ovTitle").textContent = room.title || "Today’s Puzzle";
                $("ovIntro").textContent = room.intro || "";
                $("roomTitle").textContent = room.title || "Today’s Puzzle";
                $("roomIntro").textContent = room.intro || "";

                // Safe dynamic routes blurb
                // in prefetchRoom(), after setting ovTitle/ovIntro
                // Scene-themed routes blurb (use today's labels, with explicit trade-offs)
                const routesEl = document.getElementById("ovRoutesText");
                if (routesEl) {
                    const rooms = (room.trail && room.trail.rooms) ? room.trail.rooms : [];
                    const rts = (rooms[0]?.routes) || [];
                    const map = Object.fromEntries(rts.map(r => [r.id, r]));
                    const l1 = map.cautious?.label || "Proceed carefully";
                    const l2 = map.brisk?.label || "Move quickly";
                    const l3 = map.risky?.label || "Take a risk";

                    routesEl.innerHTML =
                        `Routes are <b>scene-themed</b>. In each scene you’ll choose one path:<br>
    • <b>${l1}</b> (1×) — safer; hints unlock sooner.<br>
    • <b>${l2}</b> (2×) — faster; hints unlock <b>+30s</b>; small bonus if first try.<br>
    • <b>${l3}</b> (3×) — bold; hints unlock <b>+60s</b>; bigger first-try bonus.<br>
    Faster routes demand speed — mistakes can erase the benefit.`;
                }



            } catch (e) {
                $("ovTitle").textContent = "Mini Escape — Daily Trail";
                $("ovIntro").textContent = "Three scenes, one final lock. Pick routes and solve.";
            }
        }

        // Close the instructions by tapping the shaded backdrop
        $("overlay").addEventListener("click", (e) => {
            if (e.target === $("overlay")) { $("startBtn").click(); }
        });

        // ------- Start / Timer -------
        $("startBtn").addEventListener("click", async () => {
            $("overlay").classList.add("hidden");
            unlockScroll();                 // <— add this line
            if (!state.room) { await prefetchRoom(); }
            renderScenes(state.room);
            startTimer();
        });
        function startTimer() { state.startedMs = Date.now(); state.tickHandle = setInterval(() => { $("timer").textContent = fmtTime(Date.now() - state.startedMs); }, 33); }
        function stopTimer() { if (state.tickHandle) { clearInterval(state.tickHandle); state.tickHandle = null; } }

        // ------- Render scenes (one-at-a-time) -------
        function renderScenes(room) {
            const holder = $("scenes"); holder.innerHTML = "";
            const rooms = (room.trail && room.trail.rooms) ? room.trail.rooms : [];
            rooms.forEach((rm, idx) => {
                const wrap = document.createElement("section");
                wrap.className = "scene panel" + (idx === 0 ? " active" : "");
                wrap.id = `scene-${idx}`;
                wrap.innerHTML = `
            <h3>Scene ${idx + 1}: ${rm.title || ""}</h3>
            <div style="color:#c8d4ff">${rm.text || ""}</div>
            <div class="route-btns" id="routebtns-${idx}" style="margin-top:8px;"></div>
    
            <div class="p-card" id="pzwrap-${idx}" style="display:none;">
              <div id="pzp-${idx}" style="white-space:pre-wrap;"></div>
    
              <!-- Dynamic UI surface -->
              <div id="pzui-${idx}" style="margin-top:6px;"></div>
    
              <!-- Text input row (used for text_input and as fallback/manual entry) -->
              <div class="row" id="pzinrow-${idx}" style="margin-top:6px; display:none;">
                <input id="pzin-${idx}" type="text" placeholder="Type your answer…" autocomplete="off" />
                <button type="button" id="pzbtn-${idx}">Submit</button>
              </div>
    
              <div id="pzstatus-${idx}" class="status">Awaiting answer…</div>
    
              <div class="hint-row">
                <button class="hint-pill" id="h1btn-${idx}">Hint 1 in …</button>
                <button class="hint-pill" id="h2btn-${idx}">Hint 2 in …</button>
              </div>
              <div class="hint-text" id="h1txt-${idx}"></div>
              <div class="hint-text" id="h2txt-${idx}"></div>
    
              <div class="gloss" id="gloss-${idx}" style="display:none;"></div>
            </div>
    
            <div class="row" style="margin-top:8px;">
              <button class="btn" id="next-${idx}" style="display:none;">Next scene →</button>
            </div>
          `;
                holder.appendChild(wrap);

                // Build route buttons dynamically (works + themed)
                const btnHolder = document.getElementById(`routebtns-${idx}`);
                btnHolder.innerHTML = "";
                state.routeLocked[idx] = false;

                (rm.routes || []).forEach((r) => {
                    const rid = r.id;
                    const copy = themedRouteCopy(rm, rid, r);

                    const b = document.createElement("button");
                    b.type = "button";
                    b.className = "route-btn";
                    b.setAttribute("data-route", rid);
                    b.innerHTML = `
    <span class="route-title">${copy.label} <span class="badge">${copy.mult}</span></span>
    <span class="route-sub">${copy.sub}</span>
  `;

                    b.addEventListener("click", () => {
                        if (state.routeLocked[idx]) return;
                        state.routeLocked[idx] = true;
                        state.chosenRoutes[idx] = rid;

                        // Visually disable all three
                        btnHolder.querySelectorAll("button").forEach(x => { x.disabled = true; x.classList.add("disabled"); });

                        // Mount the puzzle and scroll to it
                        showPuzzle(idx, rm, rid);
                        document.getElementById(`pzwrap-${idx}`)?.scrollIntoView({ behavior: "smooth", block: "start" });
                    });

                    btnHolder.appendChild(b);
                });
            });
        }

        function updateFragmentDisplay() {
            const parts = state.fragments.map((f, i) => f ? `Scene ${i + 1}: <b>${f}</b>` : `Scene ${i + 1}: _ _`);
            $("fragBag").innerHTML = `Fragments — ${parts.join("  •  ")}`;
            if (state.fragments.every(Boolean)) {
                $("finalInput").placeholder = state.fragments.join("");
            }
        }

        // ------- Mini-game renderers -------
        function renderMultipleChoice(idx, uiSpec, statusEl) {
            const ui = $(`pzui-${idx}`); ui.innerHTML = "";
            const wrap = document.createElement("div");
            const opts = Array.isArray(uiSpec?.options) ? uiSpec.options : [];
            if (!opts.length) {
                wrap.innerHTML = `<div class="helper">No options provided — type your choice below.</div>`;
                $(`pzinrow-${idx}`).style.display = "flex";
                ui.appendChild(wrap);
                return;
            }
            opts.forEach(opt => {
                const btn = document.createElement("div");
                btn.className = "choice";
                btn.textContent = String(opt);
                btn.addEventListener("click", () => {
                    // toggle selection (single-select)
                    wrap.querySelectorAll(".choice").forEach(x => x.classList.remove("selected"));
                    btn.classList.add("selected");
                    state.miniAnswer[idx] = String(opt);
                    statusEl.textContent = `Selected: ${opt}`;
                    statusEl.className = "status";
                });
                wrap.appendChild(btn);
            });
            ui.appendChild(wrap);
            // show submit row as well, pre-fill on submit
            $(`pzinrow-${idx}`).style.display = "flex";
        }

        const DEFAULT_TOKENS = ["tap", "hold", "left", "right", "up", "down", "rotate_left", "rotate_right", "press", "wait"];

        // Tiny WebAudio synth for cues
        function makeSynth() {
            try { return new (window.AudioContext || window.webkitAudioContext)(); }
            catch { return null; }
        }
        function playTone(actx, type = "sine", freq = 440, ms = 200, gain = 0.05) {
            if (!actx) return Promise.resolve();
            const o = actx.createOscillator();
            const g = actx.createGain();
            o.type = type; o.frequency.value = freq;
            g.gain.value = gain;
            o.connect(g).connect(actx.destination);
            o.start();
            return new Promise(res => { setTimeout(() => { o.stop(); res(); }, ms); });
        }
        function playNoise(actx, ms = 250, gain = 0.03) {
            if (!actx) return Promise.resolve();
            const bufferSize = actx.sampleRate * (ms / 1000);
            const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.7;
            const src = actx.createBufferSource(); src.buffer = buffer;
            const g = actx.createGain(); g.gain.value = gain;
            src.connect(g).connect(actx.destination);
            src.start();
            return new Promise(res => { setTimeout(() => { try { src.stop(); } catch { } res(); }, ms); });
        }

        function renderSequenceInput(idx, uiSpec, statusEl, puzzle) {
            const ui = $(`pzui-${idx}`); ui.innerHTML = "";
            const chosen = [];

            const tokens =
                (Array.isArray(uiSpec?.sequence) && uiSpec.sequence.length) ? uiSpec.sequence :
                    (Array.isArray(uiSpec?.tokens) && uiSpec.tokens.length) ? uiSpec.tokens :
                        DEFAULT_TOKENS;

            // Legend & cues (provided by generator for richer UI)
            const legendPairs = Array.isArray(uiSpec?.legend) ? uiSpec.legend
                : (Array.isArray(puzzle?.solution?.legend) ? puzzle.solution.legend : []);
            const legendMap = Object.fromEntries(legendPairs || []);
            const cues = Array.isArray(uiSpec?.cues) ? uiSpec.cues
                : (Array.isArray(puzzle?.solution?.cues) ? puzzle.solution.cues : []);

            // 1) Cue strip (click cues to append mapped action)
            if (cues.length && Object.keys(legendMap).length) {
                const strip = document.createElement("div");
                strip.className = "cue-strip";

                // Play control
                const playBtn = document.createElement("button");
                playBtn.textContent = "▶ Play sequence";
                playBtn.style.marginRight = "8px";

                const actx = makeSynth();
                playBtn.onclick = async () => {
                    playBtn.disabled = true;
                    for (const cue of cues) {
                        // Highlight current cue bubble
                        const node = [...strip.querySelectorAll(".cue")].find(x => x.dataset.cue === cue);
                        if (node) node.classList.add("playing");

                        // Sound design (minimal but distinct)
                        if (/short beep/i.test(cue)) { await playTone(actx, "sine", 880, 160); }
                        else if (/long beep/i.test(cue)) { await playTone(actx, "sine", 660, 420); }
                        else if (/rumble/i.test(cue)) { await playTone(actx, "sine", 120, 280, 0.06); }
                        else if (/chime/i.test(cue)) { await playTone(actx, "triangle", 1200, 220, 0.05); }
                        else if (/hiss|gust/i.test(cue)) { await playNoise(actx, 220); }
                        else if (/drip/i.test(cue)) { await playTone(actx, "square", 980, 120, 0.04); }
                        else if (/clank/i.test(cue)) { await playTone(actx, "triangle", 400, 180, 0.05); }

                        await new Promise(r => setTimeout(r, 70));
                        if (node) node.classList.remove("playing");
                    }
                    playBtn.disabled = false;
                };

                ui.appendChild(playBtn);

                cues.forEach(cue => {
                    const b = document.createElement("div");
                    b.className = "cue";
                    b.dataset.cue = cue;
                    b.textContent = cue;
                    b.title = legendMap[cue] ? `→ ${legendMap[cue]}` : "";
                    b.onclick = () => {
                        const mapped = legendMap[cue];
                        if (!mapped) return;
                        chosen.push(mapped);
                        state.miniAnswer[idx] = chosen.join(",");
                        $(`pzin-${idx}`).value = state.miniAnswer[idx];
                        statusEl.textContent = `Sequence: ${state.miniAnswer[idx]}`;
                    };
                    strip.appendChild(b);
                });
                ui.appendChild(strip);
            }

            // 2) Action chips (fallback / power user)
            const box = document.createElement("div");
            box.className = "chips";
            tokens.forEach(tok => {
                const chip = document.createElement("div");
                chip.className = "chip";
                chip.textContent = tok;
                chip.addEventListener("click", () => {
                    chosen.push(tok);
                    state.miniAnswer[idx] = chosen.join(",");
                    statusEl.textContent = `Sequence: ${state.miniAnswer[idx]}`;
                    statusEl.className = "status";
                    $(`pzin-${idx}`).value = state.miniAnswer[idx];
                });
                box.appendChild(chip);
            });
            ui.appendChild(box);

            // 3) Undo/Clear + free-type
            const controls = document.createElement("div");
            controls.className = "row";
            controls.style.marginTop = "6px";
            const undo = document.createElement("button");
            undo.textContent = "Undo";
            undo.onclick = () => {
                chosen.pop();
                state.miniAnswer[idx] = chosen.join(",");
                $(`pzin-${idx}`).value = state.miniAnswer[idx];
                statusEl.textContent = `Sequence: ${state.miniAnswer[idx] || "(empty)"}`;
            };
            const clear = document.createElement("button");
            clear.textContent = "Clear";
            clear.onclick = () => {
                chosen.splice(0, chosen.length);
                state.miniAnswer[idx] = "";
                $(`pzin-${idx}`).value = "";
                statusEl.textContent = "Sequence cleared.";
            };
            controls.appendChild(undo); controls.appendChild(clear);
            ui.appendChild(controls);

            // text input also available
            $(`pzinrow-${idx}`).style.display = "flex";
            $(`pzin-${idx}`).placeholder = "Tap cues or chips — e.g., tap,hold,left,right";
        }

        function renderGridInput(idx, uiSpec, statusEl) {
            const ui = $(`pzui-${idx}`); ui.innerHTML = "";
            const grid = Array.isArray(uiSpec?.grid) ? uiSpec.grid : [];
            if (!grid.length) {
                ui.innerHTML = `<div class="helper">Grid missing — type the answer below.</div>`;
                $(`pzinrow-${idx}`).style.display = "flex"; return;
            }

            const startRC = Array.isArray(uiSpec?.start) && uiSpec.start.length === 2
                ? { r: Number(uiSpec.start[0]) || 0, c: Number(uiSpec.start[1]) || 0 }
                : null;

            const nCols = Math.max(...grid.map(r => r.length));
            const g = document.createElement("div");
            g.className = "grid";
            g.style.gridTemplateColumns = `repeat(${nCols}, minmax(36px, auto))`;

            const path = [];
            grid.forEach((row, r) => row.forEach((val, c) => {
                const cell = document.createElement("div");
                cell.className = "cell";
                if (startRC && r === startRC.r && c === startRC.c) cell.classList.add("start");
                cell.textContent = String(val);
                cell.addEventListener("click", () => {
                    cell.classList.toggle("on");
                    if (cell.classList.contains("on")) {
                        path.push(String(val));
                    } else {
                        const i = path.lastIndexOf(String(val));
                        if (i >= 0) path.splice(i, 1);
                    }
                    state.miniAnswer[idx] = path.join("");
                    $(`pzin-${idx}`).value = state.miniAnswer[idx];
                    statusEl.textContent = `Path: ${state.miniAnswer[idx] || "(none)"}`;
                });
                g.appendChild(cell);
            }));
            ui.appendChild(g);

            if (startRC) {
                const helper = document.createElement("div");
                helper.className = "helper";
                helper.textContent = "Start at the starred cell; then follow the prompt’s directions.";
                ui.appendChild(helper);
            }

            const controls = document.createElement("div");
            controls.className = "row";
            controls.style.marginTop = "6px";
            const undo = document.createElement("button");
            undo.textContent = "Undo";
            undo.onclick = () => {
                // un-toggle the last selected label if visible
                const last = path.pop();
                if (last !== undefined) {
                    // try to un-highlight a matching visible cell (best-effort)
                    const cells = g.querySelectorAll(".cell.on");
                    for (let i = cells.length - 1; i >= 0; i--) {
                        if (cells[i].textContent === last) { cells[i].classList.remove("on"); break; }
                    }
                }
                state.miniAnswer[idx] = path.join("");
                $(`pzin-${idx}`).value = state.miniAnswer[idx];
                statusEl.textContent = `Path: ${state.miniAnswer[idx] || "(none)"}`;
            };
            const clear = document.createElement("button");
            clear.textContent = "Clear";
            clear.onclick = () => {
                g.querySelectorAll(".cell.on").forEach(c => c.classList.remove("on"));
                path.splice(0, path.length);
                state.miniAnswer[idx] = "";
                $(`pzin-${idx}`).value = "";
                statusEl.textContent = "Path cleared.";
            };
            controls.appendChild(undo); controls.appendChild(clear);
            ui.appendChild(controls);

            // allow manual edit too
            $(`pzinrow-${idx}`).style.display = "flex";
            $(`pzin-${idx}`).placeholder = "Your collected letters…";
        }

        function gridEndpoints(uiSpec) {
            const g = Array.isArray(uiSpec?.grid) ? uiSpec.grid : null;
            if (!g || !g.length) return { startLabel: null, endLabel: null };

            const startLabel = g?.[0]?.[0] != null ? String(g[0][0]) : null;

            const lastRow = g[g.length - 1] || [];
            let endLabel = null;
            for (let i = lastRow.length - 1; i >= 0; i--) {
                if (lastRow[i] != null) { endLabel = String(lastRow[i]); break; }
            }
            return { startLabel, endLabel };
        }

        function normalizePromptForGrid(promptText, uiSpec) {
            let t = String(promptText || "");
            const { startLabel, endLabel } = gridEndpoints(uiSpec);
            if (!startLabel || !endLabel) return t;

            const replaced = t
                .replace(/\btop[- ]left\b/gi, startLabel)
                .replace(/\bbottom[- ]right\b/gi, endLabel);

            // If author used directional words but nothing replaced, add a clarifier.
            if (replaced === t && /top[- ]left|bottom[- ]right/i.test(t)) {
                return `${t} (Start at ${startLabel}; finish at ${endLabel}.)`;
            }
            return replaced;
        }

        // ------- Puzzle mount / hints / submit -------
        function showPuzzle(idx, rm, routeId) {
            const route = (rm.routes || []).find(r => r.id === routeId) || (rm.routes || [])[0] || {};
            const p = route.puzzle || {};
            const pw = $(`pzwrap-${idx}`); pw.style.display = "block";
            let promptText = p.prompt || "Puzzle";
            if ((p.type || p.archetype || "").toLowerCase() === "mini" &&
                (p.mechanic || "").toLowerCase() === "grid_input") {
                promptText = normalizePromptForGrid(promptText, p.ui_spec || {});
            }
            $(`pzp-${idx}`).textContent = promptText;

            const inputRow = $(`pzinrow-${idx}`);
            const input = $(`pzin-${idx}`);
            const btn = $(`pzbtn-${idx}`);
            const status = $(`pzstatus-${idx}`);
            const h1btn = $(`h1btn-${idx}`), h2btn = $(`h2btn-${idx}`), h1txt = $(`h1txt-${idx}`), h2txt = $(`h2txt-${idx}`);
            const glossBox = $(`gloss-${idx}`);

            // Glossary
            const typ = (p.type || p.archetype || "").toLowerCase();
            const G = GLOSSARY[typ] || GLOSSARY["mini"];
            if (G) { glossBox.style.display = "block"; glossBox.innerHTML = `<details><summary>${G.label}</summary><div style="margin-top:6px;color:#c8d4ff">${G.text}</div></details>`; }

            // Clear previous UI + temp answers
            state.miniAnswer[idx] = "";
            input.value = "";
            inputRow.style.display = "none";
            $(`pzui-${idx}`).innerHTML = "";

            // Mount per mechanic
            const mech = (p.mechanic || "").toLowerCase();
            if (typ === "mini") {
                if (mech === "multiple_choice") {
                    renderMultipleChoice(idx, p.ui_spec || {}, status);
                } else if (mech === "sequence_input") {
                    renderSequenceInput(idx, p.ui_spec || {}, status, p);
                } else if (mech === "grid_input") {
                    renderGridInput(idx, p.ui_spec || {}, status);
                } else {
                    // text_input or unknown → plain input
                    inputRow.style.display = "flex";
                }
            } else {
                // legacy types → plain input
                inputRow.style.display = "flex";
            }

            // Hint timers based on when THIS puzzle mounted (+30s brisk, +60s risky)
            if (!state.puzzleMountedAt) state.puzzleMountedAt = [];
            state.puzzleMountedAt[idx] = Date.now();
            const extraDelay = routeId === "brisk" ? 30000 : routeId === "risky" ? 60000 : 0;
            function updateHints() {
                const mounted = state.puzzleMountedAt[idx] || Date.now();
                const elapsed = Date.now() - mounted;
                const d1 = (state.hintPolicy.first_hint_delay_s ?? 60) * 1000 + extraDelay;
                const d2 = (state.hintPolicy.second_hint_delay_s ?? 120) * 1000 + extraDelay;
                h1btn.disabled = elapsed < d1;
                h2btn.disabled = elapsed < d2;
                h1btn.textContent = h1btn.disabled ? `Hint 1 in ${Math.max(0, Math.ceil((d1 - elapsed) / 1000))}s` : "Reveal Hint 1";
                h2btn.textContent = h2btn.disabled ? `Hint 2 in ${Math.max(0, Math.ceil((d2 - elapsed) / 1000))}s` : "Reveal Hint 2";
            }
            updateHints(); const iv = setInterval(updateHints, 250);


            // Count hints once each
            let h1Shown = false, h2Shown = false;
            h1btn.onclick = () => { if (h1btn.disabled) return; if (!h1Shown) { state.hintsUsedScene[idx] += 1; h1Shown = true; } h1txt.textContent = (p.hints || [])[0] || "No hint provided."; h1txt.style.display = "block"; };
            h2btn.onclick = () => { if (h2btn.disabled) return; if (!h2Shown) { state.hintsUsedScene[idx] += 1; h2Shown = true; } h2txt.textContent = (p.hints || [])[1] || "No additional hint."; h2txt.style.display = "block"; };

            // Submit handler — gathers the right answer source for the mechanic
            btn.onclick = async () => {
                let answer = (input.value || "").trim();
                if (typ === "mini") {
                    // prefer constructed answer if available
                    if (state.miniAnswer[idx]) answer = state.miniAnswer[idx];
                }
                if (!answer) { status.textContent = "Enter an answer."; status.className = "status"; return; }

                status.textContent = "Checking…"; status.className = "status";
                state.submissionsScene[idx] += 1;
                try {
                    const res = await fetch(`/escape/api/submit`, {
                        method: "POST", headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ date_key: state.dateKey, puzzle_id: p.id, answer })
                    });
                    const data = await res.json();
                    if (data && data.correct) {
                        const frag = (data.fragment || "").toString();
                        if (frag) {
                            state.fragments[idx] = frag;
                            updateFragmentDisplay();
                            status.innerHTML = `Correct! Fragment secured: <b>${frag}</b>`;
                        } else {
                            status.textContent = "Correct! Fragment secured.";
                        }
                        status.className = "status ok";
                        input.disabled = true; btn.disabled = true;
                        // disable mini ui
                        // AFTER
                        const ui = $(`pzui-${idx}`);
                        if (ui) ui.querySelectorAll("button,.choice,.chip,.cell").forEach(el => {
                            el.classList.add("disabled");
                            if (el.tagName === "BUTTON") el.disabled = true;
                        });
                        clearInterval(iv);
                        state.solvedScenes[idx] = true;

                        const nextBtn = $(`next-${idx}`);
                        if (idx < 2) { nextBtn.style.display = "inline-block"; nextBtn.onclick = () => goToScene(idx + 1); }
                        else { revealFinal(); }
                    } else {
                        status.textContent = "Not yet. Try another angle."; status.className = "status err";
                    }

                } catch (e) {
                    status.textContent = "Network error — try again."; status.className = "status err";
                }
            };

            // Enter submits for text fields
            input.addEventListener("keydown", e => { if (e.key === "Enter" && !btn.disabled) btn.click(); });
        }

        function goToScene(idx) {
            document.querySelectorAll(".scene").forEach(s => s.classList.remove("active"));
            $(`scene-${idx}`).classList.add("active");
            state.currentScene = idx;
            updateSceneBadge();
        }
        function updateSceneBadge() { $("sceneBadge").textContent = `Scene ${state.currentScene + 1} of 3`; }
        function revealFinal() { if (state.solvedScenes.every(Boolean)) { $("finalGate").style.display = "block"; updateFragmentDisplay(); goToScene(2); } }

        // ------- Finish flow -------
        $("finishBtn").addEventListener("click", async () => {
            if (!state.solvedScenes.every(Boolean)) { toast("Solve all scenes first."); return; }
            const finalVal = ($("finalInput").value || "").trim();
            if (!finalVal) { $("finalStatus").textContent = "Enter the final code."; $("finalStatus").className = "status err"; return; }
            try {
                const res = await fetch(`/escape/api/finish`, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        date_key: state.dateKey,
                        started_ms: state.startedMs,
                        success: true,
                        final_code: finalVal,
                        meta: {
                            ua: navigator.userAgent,
                            tz: Intl.DateTimeFormat().resolvedOptions().timeZone || null,
                            width: window.innerWidth, height: window.innerHeight,
                            routes: state.chosenRoutes.map(r => ROUTE_TO_APPROACH[r] || r),
                            hints_used_scene: state.hintsUsedScene,
                            submissions_scene: state.submissionsScene
                        }
                    })
                });
                const data = await res.json();
                if (!res.ok || !data.ok) { $("finalStatus").textContent = data.error || "Submission failed."; $("finalStatus").className = "status err"; return; }
                if (!data.success) { $("finalStatus").textContent = "Final check failed. Re-check your fragments."; $("finalStatus").className = "status err"; return; }
                stopTimer();
                $("finalStatus").textContent = "Escaped! Time submitted."; $("finalStatus").className = "status ok";
                const timeMs = data.time_ms || (Date.now() - state.startedMs);
                const shareTxt = `I escaped today’s Mini Escape in ${fmtTime(timeMs)}. Can you beat me?`;
                $("shareText").textContent = shareTxt;
                $("copyBtn").onclick = async () => {
                    try { await navigator.clipboard.writeText(`${shareTxt} ${window.location.origin}/escape/today`); toast("Copied!"); }
                    catch (e) { toast("Copy failed"); }
                };
                $("share").style.display = "block";
            } catch (e) {
                $("finalStatus").textContent = "Network error — try again."; $("finalStatus").className = "status err";
            }
        });

        // Notes events
        $("notesBox").addEventListener("input", () => { $("saveStamp").textContent = "…"; saveNotes(); });
        $("clearNotes").addEventListener("click", () => { $("notesBox").value = ""; saveNotes(); });

        // Cmd/Ctrl+Enter submits active scene’s puzzle
        document.addEventListener("keydown", (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === "Enter") {
                const idx = state.currentScene; const btn = document.getElementById(`pzbtn-${idx}`);
                if (btn && !btn.disabled) btn.click();
            }
        });
    </script>

</body>

</html>