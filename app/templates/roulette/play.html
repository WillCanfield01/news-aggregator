{% extends "base.html" %}
{% block title %}Timeline Roulette{% endblock %}
{% block content %}
<section class="container" style="max-width:900px;margin:2rem auto;padding:0 1rem;">
    <p class="mt-2">
        <a href="{{ url_for('landing') }}" style="text-decoration:none;color:#6b46c1;">← Back to Homepage</a>
    </p>

    <h1 class="mb-2">Timeline Roulette</h1>
    <p class="text-muted" style="margin-bottom:1rem;" id="prompt">Loading...</p>

    <div id="cardsWrap">
        <div id="cards" style="display:grid;grid-template-columns:1fr;gap:14px;"></div>
    </div>

    <div id="result" class="mt-3" style="display:none;margin-top:14px;font-weight:600;"></div>
    <div class="mt-2" style="margin-top:10px;">
        <a href="#" target="_blank" rel="noopener" style="display:none;" id="sourceLink">Read the real event →</a>
    </div>

    <div id="controls" style="margin-top:12px; display:flex; gap:10px; align-items:center;">
        <button id="nextBtn" style="display:none;padding:10px 16px;border:1px solid #6b46c1;color:#fff;background:#6b46c1;border-radius:8px;cursor:pointer;">Next question</button>
        <button id="restartBtn" style="display:none;padding:10px 16px;border:1px solid #6b7280;color:#374151;background:#e5e7eb;border-radius:8px;cursor:pointer;">Start over</button>
    </div>

    <div id="stats" style="margin-top:10px;color:#6b7280;font-size:0.95rem;">
        <span id="sessionScore">Score: 0/0</span> • <a href="/roulette/leaderboard">Leaderboard</a>
    </div>

    <div id="recap" style="display:none;margin-top:16px;"></div>
</section>

{% raw %}
<script>
    (function () {
        const cardsEl = document.getElementById("cards");
        const promptEl = document.getElementById("prompt");
        const resultEl = document.getElementById("result");
        const sourceLink = document.getElementById("sourceLink");
        const nextBtn = document.getElementById("nextBtn");
        const restartBtn = document.getElementById("restartBtn");
        const sessionScore = document.getElementById("sessionScore");
        const recapEl = document.getElementById("recap");

        let state = { step: 1, score: 0, payload: null, locked: false };

        function renderCards(payload) {
            cardsEl.innerHTML = "";
            sourceLink.style.display = payload.source_url ? "inline-block" : "none";
            if (payload.source_url) sourceLink.href = payload.source_url;
            payload.cards.forEach((card, idx) => {
                const btn = document.createElement("button");
                btn.className = "card";
                btn.dataset.idx = idx;
                btn.style.cssText = "padding:0;border-radius:14px;border:1px solid #e5e7eb;background:#fff;cursor:pointer;overflow:hidden;";

                // Image-only layout for image rounds
                const imgHtml = card.img ? `<img src="${card.img}" alt="" style="display:block;width:100%;height:240px;object-fit:cover;">` : "";
                const textHtml = (payload.type === "image") ? "" : `
                    <div style="padding:12px 16px;">
                        <div style="font-weight:600;color:#374151;">Choice ${idx + 1}</div>
                        <div style="color:#111827;">${card.text}</div>
                    </div>
                `;
                btn.innerHTML = imgHtml + textHtml;
                btn.addEventListener("click", () => handleGuess(idx, payload.correct_index));
                cardsEl.appendChild(btn);
            });
        }

        function lockButtons(correctIdx, pickedIdx) {
            const buttons = cardsEl.querySelectorAll("button");
            buttons.forEach((btn, i) => {
                btn.disabled = true;
                btn.style.border = (i === correctIdx) ? "2px solid #10b981" : "1px solid #ef4444";
                btn.style.background = (i === correctIdx) ? "#ecfdf5" : "#fff";
            });
        }

        async function fetchSession() {
            const res = await fetch("/roulette/session");
            if (!res.ok) throw new Error("session fetch failed");
            const data = await res.json();
            state.step = data.step;
            state.score = data.score;
            state.payload = data.payload;
            sessionScore.textContent = `Score: ${state.score}/${Math.min(state.step - 1, 3)}`;
            promptEl.textContent = data.payload.prompt || "Pick the real one.";
            resultEl.style.display = "none";
            nextBtn.style.display = "none";
            restartBtn.style.display = "none";
            recapEl.style.display = "none";
            renderCards(data.payload);
        }

        async function handleGuess(idx, correctIdx) {
            if (state.locked) return;
            state.locked = true;
            lockButtons(correctIdx, idx);
            try {
                const res = await fetch("/roulette/session/guess", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ choice: idx })
                });
                const data = await res.json();
                if (data.ok) {
                    const msg = data.is_correct ? "✅ Correct!" : "❌ Not quite.";
                    resultEl.textContent = msg;
                    resultEl.style.display = "block";
                    state.score = data.score;
                    sessionScore.textContent = `Score: ${Math.min(state.score,3)}/${Math.min(state.step, 3)}`;
                    nextBtn.style.display = "inline-block";
                }
            } catch (e) { }
        }

        async function nextStep() {
            const res = await fetch("/roulette/session/next", { method: "POST" });
            const data = await res.json();
            if (!data.ok) return;
            if (data.rounds) {
                // recap
                showRecap(data);
                return;
            }
            state.step = data.step;
            state.score = data.score;
            state.payload = data.payload;
            sessionScore.textContent = `Score: ${Math.min(state.score,3)}/${Math.min(state.step - 1, 3)}`;
            promptEl.textContent = data.payload.prompt || "Pick the real one.";
            resultEl.style.display = "none";
            nextBtn.style.display = "none";
            renderCards(data.payload);
            state.locked = false;
        }

        function showRecap(data) {
            const rounds = data.rounds;
            recapEl.innerHTML = `<h3 style="margin-top:12px;">Recap (Score: ${data.score}/3)</h3>`;
            ["text", "image", "quote"].forEach((key) => {
                const r = rounds[key];
                if (!r || !r.payload) return;
                const guess = r.guess;
                const correct = r.payload.correct_index;
                const heading = key === "text" ? "Events" : key === "image" ? "Images" : "Quotes";
                const block = document.createElement("div");
                block.style.marginTop = "10px";
                block.innerHTML = `<div style="font-weight:600;">${heading}</div>`;
                r.payload.cards.forEach((c, i) => {
                    const line = document.createElement("div");
                    line.style.marginLeft = "8px";
                    const mark = (i === correct) ? "✅" : (i === guess ? "❌" : "•");
                    line.textContent = `${mark} ${c.text}`;
                    block.appendChild(line);
                });
                recapEl.appendChild(block);
            });
            recapEl.style.display = "block";
            nextBtn.style.display = "none";
            restartBtn.style.display = "inline-block";
        }

        restartBtn.addEventListener("click", async () => {
            try {
                await fetch("/roulette/session/reset", { method: "POST" });
            } catch (e) { }
            state.locked = false;
            await fetchSession();
        });
        nextBtn.addEventListener("click", () => { state.locked = false; nextStep(); });

        fetchSession().catch(() => {
            promptEl.textContent = "Unable to start game right now.";
        });
    })();
</script>
{% endraw %}
{% endblock %}
